<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Europa Preiskarte ‚Äì Unit Auswahl</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html,body{height:100%;margin:0;}
    #map{width:100%;height:100%;}

    .legend, .cert-box{
      position:absolute;background:#fff;padding:8px 10px;border-radius:6px;
      box-shadow:0 2px 8px rgba(0,0,0,.12);
      font:14px/1.3 system-ui,Arial,sans-serif;
    }
    .cert-box{bottom:12px;left:12px;z-index:1000;}
    .legend{bottom:12px;right:12px;min-width:180px;z-index:3000;}

    .cert-box input[type="checkbox"],
    .legend input[type="checkbox"]{width:14px;height:14px;margin-right:5px;vertical-align:middle;}

    .search-box{
      position:absolute;top:12px;right:12px;z-index:1500;background:#fff;
      padding:8px 10px;border-radius:6px;box-shadow:0 2px 8px rgba(0,0,0,.15);
      font:14px system-ui,Arial,sans-serif;width:280px;
    }
    .search-box input[type="text"], .search-box select{
      width:100%;padding:6px 8px;border:1px solid #ccc;border-radius:4px;
      outline:none;box-sizing:border-box;margin-left:4px;
    }
    .search-hint{margin-top:6px;font-size:12px;opacity:.75;line-height:1.25;}
    .cert-box hr{border:none;height:1px;background:#eee;margin:6px 0;}

    .country-dropdown{position:relative;display:block;width:100%;margin-top:8px;}
    .country-dropdown-button{
      width:100%;background:#fff;border:1px solid #ccc;border-radius:4px;
      padding:4px 6px;text-align:left;cursor:pointer;box-sizing:border-box;
    }
    .country-dropdown-button:after{content:"‚ñæ";float:right;opacity:.6;}
    .country-dropdown-menu{
      position:absolute;top:110%;left:0;background:#fff;border:1px solid #ccc;
      border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,.12);
      z-index:4000;display:none;min-width:160px;max-height:260px;overflow-y:auto;
      padding:8px 10px;box-sizing:border-box;
    }
    .country-dropdown-menu label{
      display:flex;align-items:center;gap:8px;margin:6px 0;cursor:pointer;user-select:none;
    }
    .country-dropdown-menu label input[type="checkbox"]{margin:0;width:14px;height:14px;flex:0 0 auto;}

    /* Start: alle Panels versteckt */
    #panelSaegerestholz, #legendSaegerestholz,
    #panelPellets, #legendPellets { display:none; }
  </style>
</head>
<body>

<div id="map"></div>

<!-- Suche + L√§nderfilter + Unit -->
<div class="search-box">
  üîç <input type="text" id="searchInput" placeholder="Firma, Kunde oder Ort/Adresse suchen‚Ä¶"/>
  <div class="search-hint" id="searchHint">W√§hle zuerst eine Unit.</div>

  <b style="display:block;margin-top:10px;">Land / L√§nder filtern</b>
  <div class="country-dropdown" id="countryDropdown">
    <div class="country-dropdown-button" id="countryDropdownBtn">Alle L√§nder</div>
    <div class="country-dropdown-menu" id="countryDropdownMenu">
      <label><input type="checkbox" class="countryChk" value="all" checked> Alle</label>
      <label><input type="checkbox" class="countryChk" value="be"> Belgien</label>
      <label><input type="checkbox" class="countryChk" value="dk"> D√§nemark</label>
      <label><input type="checkbox" class="countryChk" value="de"> Deutschland</label>
      <label><input type="checkbox" class="countryChk" value="ee"> Estland</label>
      <label><input type="checkbox" class="countryChk" value="fi"> Finnland</label>
      <label><input type="checkbox" class="countryChk" value="fr"> Frankreich</label>
      <label><input type="checkbox" class="countryChk" value="it"> Italien</label>
      <label><input type="checkbox" class="countryChk" value="lv"> Lettland</label>
      <label><input type="checkbox" class="countryChk" value="lt"> Litauen</label>
      <label><input type="checkbox" class="countryChk" value="nl"> Niederlande</label>
      <label><input type="checkbox" class="countryChk" value="at"> √ñsterreich</label>
      <label><input type="checkbox" class="countryChk" value="pl"> Polen</label>
      <label><input type="checkbox" class="countryChk" value="se"> Schweden</label>
      <label><input type="checkbox" class="countryChk" value="ch"> Schweiz</label>
      <label><input type="checkbox" class="countryChk" value="sk"> Slowakei</label>
      <label><input type="checkbox" class="countryChk" value="cz"> Tschechien</label>
      <label><input type="checkbox" class="countryChk" value="gb"> United Kingdom</label>
    </div>
  </div>

  <b style="display:block;margin-top:10px;">Unit</b>
  <select id="unitSelect">
    <option value="" selected>Bitte ausw√§hlen‚Ä¶</option>
    <option value="pellets">Pellets</option>
    <option value="saegerestholz">S√§gerestholz</option>
  </select>
</div>

<!-- ====================== S√ÑGERESTHOLZ PANEL ====================== -->
<div class="cert-box" id="panelSaegerestholz">
  <b>Zertifikate</b><br>
  <label><input type="checkbox" id="chkSURE" checked> SURE</label><br>
  <label><input type="checkbox" id="chkPEFC" checked> PEFC</label><br>
  <label><input type="checkbox" id="chkOhneZert" checked> Kein Zertifikat</label>
  <hr>
  <b>Produkt</b><br>
  <label><input type="checkbox" id="chkHackschnitzel" checked> Hackschnitzel</label><br>
  <label><input type="checkbox" id="chkSaegespaene" checked> S√§gesp√§ne</label><br>
  <label><input type="checkbox" id="chkSiebmaterial" checked> Siebmaterial</label><br>
  <label><input type="checkbox" id="chkPelletabrieb" checked> Pelletabrieb</label>
</div>

<div class="legend" id="legendSaegerestholz">
  <b>Filter Farben</b><br>
  <label><input type="checkbox" id="chkGruen" checked> üü¢ ‚â§ 260 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkOrange" checked> üü† 260‚Äì285 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkRot" checked> üî¥ ‚â• 285 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkGrau" checked> ‚ö™ kein Preis</label><br>
  <label><input type="checkbox" id="chkKunden" checked> üî∑ Pelletwerk</label>
</div>

<!-- ====================== PELLETS PANEL ====================== -->
<div class="cert-box" id="panelPellets">
  <b>Zertifikate & Sackware</b><br>
  <label><input type="checkbox" id="p_chkEnPlus" checked> EnPlus</label><br>
  <label><input type="checkbox" id="p_chkDINplus" checked> DINplus</label><br>
  <label><input type="checkbox" id="p_chkSURE" checked> SURE</label><br>
  <label><input type="checkbox" id="p_chkCPP" checked> CPP</label><br>
  <label><input type="checkbox" id="p_chkOhneZert" checked> Kein Zertifikat</label>
  <hr>
  <b>Sackware</b><br>
  <label><input type="checkbox" id="p_chkSackFireflies"> FireFlies</label><br>
  <label><input type="checkbox" id="p_chkSack15kg"> 15 kg</label>
</div>

<div class="legend" id="legendPellets">
  <b>Filter Farben</b><br>
  <label><input type="checkbox" id="p_chkGruen" checked> üü¢ ‚â§ 260 ‚Ç¨</label><br>
  <label><input type="checkbox" id="p_chkOrange" checked> üü† 260‚Äì285 ‚Ç¨</label><br>
  <label><input type="checkbox" id="p_chkRot" checked> üî¥ ‚â• 285 ‚Ç¨</label><br>
  <label><input type="checkbox" id="p_chkGrau" checked> ‚ö™ kein Preis</label><br>
  <label><input type="checkbox" id="p_chkKunden" checked> üî∑ Pelleth√§ndler</label><br>
  <label><input type="checkbox" id="p_chkSackKunden" checked> üü£ Sackwaren H√§ndler</label><br>
  <label><input type="checkbox" id="p_chkSonstigeKunden" checked> üî∂ Sonstige Kunden</label>
</div>

<script>
/* =========================================================
   GEMEINSAM: MAP + HELPER
========================================================= */

const map = L.map("map", { maxZoom: 19 }).setView([51, 11], 5);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  minZoom: 4, maxZoom: 19, attribution: "&copy; OpenStreetMap"
}).addTo(map);

function colorForPrice(p, keinPreis) {
  if (keinPreis) return "#9e9e9e";
  if (!p || p <= 0 || isNaN(p)) return "#9e9e9e";
  if (p <= 260) return "green";
  if (p < 285) return "orange";
  return "red";
}

// L√§ndername -> country_code
function countryCodeFromLand(landRaw){
  const s = String(landRaw||"").toLowerCase().trim();
  if (!s) return "";
  if (s.includes("deutschland") || s === "de") return "de";
  if (s.includes("√∂sterreich") || s.includes("austria") || s === "at") return "at";
  if (s.includes("schweiz") || s.includes("switzerland") || s === "ch") return "ch";
  if (s.includes("frankreich") || s.includes("france") || s === "fr") return "fr";
  if (s.includes("polen") || s.includes("poland") || s === "pl") return "pl";
  if (s.includes("tschechien") || s.includes("czech") || s === "cz") return "cz";
  if (s.includes("slowakei") || s.includes("slovakia") || s === "sk") return "sk";
  if (s.includes("belgien") || s.includes("belgium") || s === "be") return "be";
  if (s.includes("d√§nemark") || s.includes("denmark") || s === "dk") return "dk";
  if (s.includes("schweden") || s.includes("sweden") || s === "se") return "se";
  if (s.includes("finnland") || s.includes("finland") || s === "fi") return "fi";
  if (s.includes("italien") || s.includes("italy") || s === "it") return "it";
  if (s.includes("estland") || s.includes("estonia") || s === "ee") return "ee";
  if (s.includes("lettland") || s.includes("latvia") || s === "lv") return "lv";
  if (s.includes("litauen") || s.includes("lithuania") || s === "lt") return "lt";
  if (s.includes("niederlande") || s.includes("netherlands") || s === "nl") return "nl";
  if (s.includes("united kingdom") || s.includes("uk") || s.includes("england") || s === "gb") return "gb";
  return "";
}

// ---- Zahl robust parsen (auch "58,24 ‚Ç¨") ----
function parseFloatSmart(v){
  const s = String(v ?? "")
    .replace(/\s/g, "")
    .replace("‚Ç¨","")
    .replace(/[^0-9,.\-]/g, "")
    .replace(",", ".");
  const n = parseFloat(s);
  return isFinite(n) ? n : NaN;
}

function pickKey(keys, candidates){
  const lc = (x)=>String(x||"").toLowerCase().trim();
  const set = new Set(candidates.map(c=>c.toLowerCase()));
  return keys.find(k => set.has(lc(k)));
}
function extractLatLonFromRow(row, keys){
  if (!row) return { lat: NaN, lon: NaN };

  const latKey = pickKey(keys, ["lat","latitude","breite","breitengrad"]);
  const lonKey = pickKey(keys, ["lon","lng","longitude","l√§ngengrad","laengengrad"]);

  let lat = latKey ? parseFloatSmart(row[latKey]) : NaN;
  let lon = lonKey ? parseFloatSmart(row[lonKey]) : NaN;

  if (!(isFinite(lat) && isFinite(lon))) {
    const keyR = keys[17]; // R
    const keyS = keys[18]; // S
    if (keyR && keyS) {
      lat = parseFloatSmart(row[keyR]);
      lon = parseFloatSmart(row[keyS]);
    }
  }

  if (!(isFinite(lat) && isFinite(lon))) return { lat: NaN, lon: NaN };
  if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return { lat: NaN, lon: NaN };
  return { lat, lon };
}

/* =========================================================
   OPTIONAL: Geocode nur wenn Lat/Lon fehlen
========================================================= */

const GEO_CACHE_KEY = "geoCache_MULTI_EU_v1";
const geoCache = JSON.parse(localStorage.getItem(GEO_CACHE_KEY) || "{}");
const inFlight = new Map();

async function geocodeOnce(q) {
  if (geoCache[q] && geoCache[q].country_code) return geoCache[q];
  if (inFlight.has(q)) return inFlight.get(q);

  const p = (async ()=>{
    const r = await fetch(
      `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&q=${encodeURIComponent(q)}&limit=1&accept-language=de`,
      { headers: { "Accept": "application/json" } }
    );
    const d = await r.json();
    if (d && d.length) {
      const item = d[0];
      const obj = {
        lat: +item.lat,
        lon: +item.lon,
        country: item.address && item.address.country ? item.address.country : "",
        country_code: item.address && item.address.country_code ? item.address.country_code.toLowerCase() : ""
      };
      geoCache[q] = obj;
      localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(geoCache));
      return obj;
    }
    return null;
  })();

  inFlight.set(q, p);
  try { return await p; }
  finally { inFlight.delete(q); }
}

async function geocodeWithFallback(queries){
  for (const q of queries) {
    const qq = (q || "").trim();
    if (!qq) continue;
    const res = await geocodeOnce(qq);
    if (res) return res;
  }
  return null;
}

/* =========================================================
   Icons
========================================================= */

const blauesDreieck = L.divIcon({
  className: "custom-triangle",
  html: `<svg width="24" height="24" viewBox="0 0 24 24">
           <polygon points="12,2 22,22 2,22" fill="blue" stroke="black" stroke-width="1"/>
         </svg>`,
  iconAnchor: [12,22],
  popupAnchor: [0,-20]
});
const lilaDreieck = L.divIcon({
  className: "custom-triangle-purple",
  html: `<svg width="24" height="24" viewBox="0 0 24 24">
           <polygon points="12,2 22,22 2,22" fill="purple" stroke="black" stroke-width="1"/>
         </svg>`,
  iconAnchor: [12,22],
  popupAnchor: [0,-20]
});
const orangeDreieck = L.divIcon({
  className: "custom-triangle-orange",
  html: `<svg width="24" height="24" viewBox="0 0 24 24">
           <polygon points="12,2 22,22 2,22" fill="orange" stroke="black" stroke-width="1"/>
         </svg>`,
  iconAnchor: [12,22],
  popupAnchor: [0,-20]
});
const ortIcon = L.divIcon({
  className: "custom-place",
  html: `<svg width="26" height="26" viewBox="0 0 24 24">
    <path d="M12 2c-3.3 0-6 2.7-6 6 0 4.5 6 14 6 14s6-9.5 6-14c0-3.3-2.7-6-6-6z" fill="#111" stroke="#fff" stroke-width="1.2"/>
    <circle cx="12" cy="8" r="2.4" fill="#fff"/>
  </svg>`,
  iconAnchor: [13,24],
  popupAnchor: [0,-18]
});

/* =========================================================
   L√§nderfilter UI
========================================================= */

function getSelectedCountries() {
  const chks = document.querySelectorAll(".countryChk");
  const selected = [];
  chks.forEach(ch => { if (ch.checked) selected.push(ch.value); });
  if (selected.length === 0 || selected.includes("all")) return ["all"];
  return selected;
}
function updateCountryButtonLabel() {
  const btn = document.getElementById("countryDropdownBtn");
  if (!btn) return;
  const selected = getSelectedCountries();
  if (selected.length === 1 && selected[0] === "all") btn.textContent = "Alle L√§nder";
  else {
    const names = {
      de:"DE", at:"AT", pl:"PL", cz:"CZ", fr:"FR", ch:"CH", be:"BE", sk:"SK",
      dk:"DK", ee:"EE", fi:"FI", it:"IT", lv:"LV", lt:"LT", nl:"NL", se:"SE", gb:"GB"
    };
    btn.textContent = selected.map(c => names[c] || c.toUpperCase()).join(", ");
  }
}
document.getElementById("countryDropdownBtn").addEventListener("click", () => {
  const menu = document.getElementById("countryDropdownMenu");
  menu.style.display = (menu.style.display === "block") ? "none" : "block";
});
document.addEventListener("click", (e) => {
  const dd = document.getElementById("countryDropdown");
  const menu = document.getElementById("countryDropdownMenu");
  if (!dd || !menu) return;
  if (!dd.contains(e.target)) menu.style.display = "none";
});
document.addEventListener("change", (e) => {
  if (e.target && e.target.classList && e.target.classList.contains("countryChk")) {
    if (e.target.value === "all" && e.target.checked) {
      document.querySelectorAll(".countryChk").forEach(ch => { if (ch.value !== "all") ch.checked = false; });
    } else if (e.target.value !== "all" && e.target.checked) {
      const allChk = document.querySelector('.countryChk[value="all"]');
      if (allChk) allChk.checked = false;
    }
    updateCountryButtonLabel();
    if (currentUnit && currentUnit.updateLayers) currentUnit.updateLayers();
  }
});

/* =========================================================
   UNIT MANAGER
========================================================= */

let currentUnit = null;

function hideAllPanels(){
  document.getElementById("panelSaegerestholz").style.display = "none";
  document.getElementById("legendSaegerestholz").style.display = "none";
  document.getElementById("panelPellets").style.display = "none";
  document.getElementById("legendPellets").style.display = "none";
}

function clearMapState(unit){
  if (!unit) return;
  (unit.alleMarker || []).forEach(m => {
    if (m.marker && map.hasLayer(m.marker)) map.removeLayer(m.marker);
  });
  if (unit.routeLine && map.hasLayer(unit.routeLine)) map.removeLayer(unit.routeLine);
  unit.routeLine = null;
  unit.selectedPoints = [];
  if (unit.tempSearchMarker && map.hasLayer(unit.tempSearchMarker)) map.removeLayer(unit.tempSearchMarker);
  unit.tempSearchMarker = null;
  if (unit.searchResultMarker && map.hasLayer(unit.searchResultMarker)) map.removeLayer(unit.searchResultMarker);
  unit.searchResultMarker = null;
  map.closePopup();
}

document.getElementById("unitSelect").addEventListener("change", async (e) => {
  const v = e.target.value;
  const hint = document.getElementById("searchHint");

  if (currentUnit) clearMapState(currentUnit);
  currentUnit = null;

  hideAllPanels();

  if (!v) {
    hint.textContent = "W√§hle zuerst eine Unit.";
    return;
  }

  if (v === "saegerestholz") {
    hint.textContent = "S√§gerestholz aktiv. 2 Punkte klicken ‚Üí Route + Preis.";
    document.getElementById("panelSaegerestholz").style.display = "block";
    document.getElementById("legendSaegerestholz").style.display = "block";
    currentUnit = createSaegerestholzUnit();
  }

  if (v === "pellets") {
    hint.textContent = "Pellets aktiv. 2 Punkte klicken ‚Üí Route + Preis.";
    document.getElementById("panelPellets").style.display = "block";
    document.getElementById("legendPellets").style.display = "block";
    currentUnit = createPelletsUnit();
  }

  try{
    await currentUnit.init();
  }catch(err){
    console.error(err);
    alert("Fehler beim Laden der Unit. Konsole (F12) anschauen.");
  }
});

document.getElementById("searchInput").addEventListener("keydown", async (e) => {
  if (e.key !== "Enter") return;
  const q = (e.target.value || "").trim();
  if (!q) return;

  if (!currentUnit) {
    alert("Bitte zuerst eine Unit ausw√§hlen.");
    return;
  }
  try{
    await currentUnit.searchOrGeocode(q);
  }catch(err){
    console.error(err);
    alert("Fehler bei Suche/Geocoding.");
  }
});

map.on('click', (e) => {
  const t = e.originalEvent && e.originalEvent.target;
  if (t && t.closest) {
    if (t.closest('.leaflet-marker-icon') ||
        t.closest('.leaflet-popup') ||
        t.closest('.leaflet-interactive')) return;
  }
  if (currentUnit) {
    if (currentUnit.routeLine) { map.removeLayer(currentUnit.routeLine); currentUnit.routeLine = null; }
    currentUnit.selectedPoints = [];
    map.closePopup();
  }
});

document.addEventListener("change", (e) => {
  if (!currentUnit) return;
  if (e.target && e.target.matches('input[type="checkbox"]') && !e.target.classList.contains("countryChk")) {
    currentUnit.updateLayers();
  }
});

/* =========================================================
   UNIT: S√ÑGERESTHOLZ (inkl. Pelletabrieb)
========================================================= */

function createSaegerestholzUnit(){
  const sheetUrlFirmen = "https://docs.google.com/spreadsheets/d/1GIBV-WAyaslfi175jpbif0bHw8YWAhriifM7CtDUB2k/gviz/tq?tqx=out:csv&gid=0";
  const sheetUrlKunden = "https://docs.google.com/spreadsheets/d/148jjtRze9SmuFsDNRfoM_nwEih7GbCzOjMUQEAb78pg/gviz/tq?tqx=out:csv&gid=0";

  const MARGE = 1.05;

  const HACKS_TEILER = 90;
  const HACKS_KM_UNTER_GLEICH_200 = 2.15;
  const HACKS_KM_UEBER_200        = 2.15;

  const SAEG_TEILER = 90;
  const SAEG_KM_UNTER_GLEICH_200 = 2.15;
  const SAEG_KM_UEBER_200        = 2.15;

  const SIEB_TONNE = 21.50;
  const SIEB_KM_SATZ = 1.85;
  const SIEB_ATRO = 11.8;

  // Pelletabrieb: kmSatz bleibt wie vorher (2.15/1.85), aber neue Struktur: (EK + ((km*kmSatz)/24)) * 1.05
  const ABR_TEILER = 24;
  function abrKmSatz(km){ return (km < 250) ? 2.15 : 1.85; }

  function calcHackschnitzel(ek, km){
    if (!(isFinite(ek) && ek > 0)) return null;
    const kmSatz = (km <= 200) ? HACKS_KM_UNTER_GLEICH_200 : HACKS_KM_UEBER_200;
    return (ek + ((km * kmSatz) / HACKS_TEILER)) * MARGE;
  }
  function calcSaegespaene(ek, km){
    if (!(isFinite(ek) && ek > 0)) return null;
    const kmSatz = (km <= 200) ? SAEG_KM_UNTER_GLEICH_200 : SAEG_KM_UEBER_200;
    return (ek + ((km * kmSatz) / SAEG_TEILER)) * MARGE;
  }
  function calcSiebmaterial(ek, km){
    if (!(isFinite(ek) && ek > 0)) return null;
    return (((ek * SIEB_TONNE) + (SIEB_KM_SATZ * km)) / SIEB_ATRO) * MARGE;
  }

  // ‚úÖ NEU: Pelletabrieb Preis = (EK + ((km*kmSatz)/24)) * 1.05
  function calcPelletabriebPreis(ek, km){
    if (!(isFinite(ek) && ek > 0)) return null;
    const kmSatz = abrKmSatz(km);
    return (ek + ((km * kmSatz) / ABR_TEILER)) * 1.05;
  }

  // ‚úÖ Marge bleibt: Ziel - Basis (ohne *1,05), aber Basis ist jetzt EK + ((km*kmSatz)/24)
  function calcPelletabriebMarge(zielpreis, ek, km){
    if (!(isFinite(zielpreis) && isFinite(ek) && isFinite(km))) return null;
    const kmSatz = abrKmSatz(km);
    const basis = ek + ((km * kmSatz) / ABR_TEILER);
    return zielpreis - basis;
  }

  function normProduktName(p){
    const s = (p || "").toLowerCase();
    if (s.includes("hackschnitzel")) return "hackschnitzel";
    if (s.includes("s√§gesp√§ne") || s.includes("saegespaene") || s.includes("s√§gespaene") || s.includes("saegesp√§ne")) return "saegespaene";
    if (s.includes("siebmaterial")) return "siebmaterial";
    if (s.includes("pelletabrieb") || s.includes("pellet abrieb") || (s.includes("abrieb") && s.includes("pellet"))) return "pelletabrieb";
    return "";
  }

  async function loadCsvAsObjects(url){
    const res = await fetch(url, { cache: "no-store" });
    const text = await res.text();
    const head = text.slice(0, 150).toLowerCase();
    if (head.includes("<html") || head.includes("<!doctype")) throw new Error("Google liefert HTML statt CSV.");
    const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
    return (parsed.data || []).filter(r => r && Object.keys(r).length);
  }

  function parseFirmen(rows){
    const lc = (s)=>String(s||"").toLowerCase().trim();
    const keys = Object.keys(rows[0]||{});
    const findKey = (cands) => keys.find(k => cands.includes(lc(k)));

    const firmaKey = findKey(["firma","name","werk"]) || "firma";
    const plzKey   = findKey(["plz","zip","postcode","postleitzahl"]) || "plz";
    const ortKey   = findKey(["ort","stadt","location","standort","adresse"]) || "ort";
    const landKey  = findKey(["land","country"]) || "land";

    const zertKeyQ = keys[16];
    const zertKeyFallback = keys.find(k => ["zertifikate","zertifikat","zert","cert"].includes(lc(k)));
    const zertKey = zertKeyQ || zertKeyFallback;

    const produktKeys = keys.filter(k => lc(k).startsWith("produkt"));
    const preisKeys   = keys.filter(k => lc(k).startsWith("preis"));

    return rows.map(x => {
      const prices = {};
      const pairs = Math.max(produktKeys.length, preisKeys.length);

      for (let i=0; i<pairs; i++){
        const pKey = produktKeys[i];
        const rKey = preisKeys[i];

        const prodRaw  = pKey ? (x?.[pKey] || "").toString().trim() : "";
        const priceRaw = rKey ? (x?.[rKey] ?? "").toString() : "";

        const prodNorm = normProduktName(prodRaw);
        const priceVal = parseFloatSmart(priceRaw);

        if (prodNorm && isFinite(priceVal) && priceVal > 0) prices[prodNorm] = priceVal;
        else if (prodNorm && !(prodNorm in prices)) prices[prodNorm] = 0;
      }

      // ‚úÖ Pelletabrieb EK aus Spalte L (Index 11)
      const preis4Key = keys[11]; // L
      const abrEk = parseFloatSmart(x?.[preis4Key] ?? "");
      if (isFinite(abrEk) && abrEk > 0) prices.pelletabrieb = abrEk;
      else if (!("pelletabrieb" in prices)) prices.pelletabrieb = 0;

      const { lat, lon } = extractLatLonFromRow(x, keys);

      const land = (x[landKey]||"").toString().trim();
      const cc = countryCodeFromLand(land);

      return {
        firma: (x[firmaKey]||"").toString().trim(),
        plz: (x[plzKey]||"").toString().trim(),
        ort: (x[ortKey]||"").toString().trim(),
        land,
        country_code: cc,
        prices,
        zert: zertKey ? (x?.[zertKey]||"").toString().trim() : "",
        lat, lon
      };
    }).filter(w => w.firma && (w.plz || w.ort));
  }

  function parseKunden(rows){
    const lc = (s)=>String(s||"").toLowerCase().trim();
    const keys = Object.keys(rows[0]||{});
    const findKey = (cands) => keys.find(k => cands.includes(lc(k)));

    const kundeKey = findKey(["kunde","name","firma","unternehmen"]) || "kunde";
    const plzKey   = findKey(["plz","zip","postcode","postleitzahl"]) || "plz";
    const ortKey   = findKey(["ort","stadt","location","adresse","standort"]) || "ort";
    const landKey  = findKey(["land","country"]) || "land";

    // ‚úÖ Spalte E/F: Produkt / Zielpreis
    const prodKey = keys[4]; // E
    const zielKey = keys[5]; // F

    return rows.map(x => {
      const { lat, lon } = extractLatLonFromRow(x, keys);
      const land = (x[landKey]||"").toString().trim();

      const prodRaw = (prodKey ? (x?.[prodKey] ?? "") : "").toString().trim();
      const zielpreis = parseFloatSmart(zielKey ? (x?.[zielKey] ?? "") : "");
      const prodNorm = normProduktName(prodRaw);

      return {
        name: (x[kundeKey]||"").toString().trim(),
        plz: (x[plzKey]||"").toString().trim(),
        ort: (x[ortKey]||"").toString().trim(),
        land,
        country_code: countryCodeFromLand(land),
        lat, lon,
        produktRaw: prodRaw,
        produktNorm: prodNorm,
        zielpreis: isFinite(zielpreis) ? zielpreis : NaN
      };
    }).filter(k => k.name && (k.plz || k.ort));
  }

  function buildQueries(obj){
    const plz = (obj.plz||"").trim();
    const ort = (obj.ort||"").trim();
    const land = (obj.land||"").trim();
    const q1 = `${plz} ${ort}, ${land}`.replace(/\s+/g," ").trim();
    const q2 = `${plz} ${ort}`.replace(/\s+/g," ").trim();
    const q3 = `${ort}, ${land}`.replace(/\s+/g," ").trim();
    const q4 = `${ort}`.trim();
    return [q1,q2,q3,q4];
  }

  function tooltipHtmlFirma(m){
    const landInfo = m.land ? `<br><b>Land:</b> ${m.land}` : "";
    const place = `${m.plz ? m.plz+" " : ""}${m.ort || ""}`.trim();

    const pH = m.prices?.hackschnitzel;
    const pS = m.prices?.saegespaene;
    const pM = m.prices?.siebmaterial;
    const pA = m.prices?.pelletabrieb;

    const lineH = (pH !== undefined) ? `<b>Hackschnitzel:</b> ${isFinite(pH) && pH>0 ? pH.toFixed(2)+" ‚Ç¨" : "‚Äì"}` : "";
    const lineS = (pS !== undefined) ? `<b>S√§gesp√§ne:</b> ${isFinite(pS) && pS>0 ? pS.toFixed(2)+" ‚Ç¨" : "‚Äì"}` : "";
    const lineM = (pM !== undefined) ? `<b>Siebmaterial:</b> ${isFinite(pM) && pM>0 ? pM.toFixed(2)+" ‚Ç¨" : "‚Äì"}` : "";
    const lineA = (pA !== undefined) ? `<b>Pelletabrieb (EK):</b> ${isFinite(pA) && pA>0 ? pA.toFixed(2)+" ‚Ç¨" : "‚Äì"}` : "";

    const lines = [lineH,lineS,lineM,lineA].filter(Boolean).join("<br>");
    return `<b>${m.firma}</b><br>${place}${landInfo}${lines ? "<br>"+lines : ""}`;
  }

  function activePriceForFirma(w){
    const showHacks = document.getElementById("chkHackschnitzel")?.checked ?? true;
    const showSaeg  = document.getElementById("chkSaegespaene")?.checked ?? true;
    const showSieb  = document.getElementById("chkSiebmaterial")?.checked ?? true;
    const showAbr   = document.getElementById("chkPelletabrieb")?.checked ?? true;

    const pH = w.prices?.hackschnitzel;
    const pS = w.prices?.saegespaene;
    const pM = w.prices?.siebmaterial;
    const pA = w.prices?.pelletabrieb;

    const list = [];
    if (showHacks && isFinite(pH) && pH > 0) list.push(pH);
    if (showSaeg  && isFinite(pS) && pS > 0) list.push(pS);
    if (showSieb  && isFinite(pM) && pM > 0) list.push(pM);
    if (showAbr   && isFinite(pA) && pA > 0) list.push(pA);

    if (!list.length) return { price: 0, keinPreis: true };
    return { price: Math.min(...list), keinPreis: false };
  }

  async function coordForRow(row){
    if (isFinite(row.lat) && isFinite(row.lon)) {
      return { lat: row.lat, lon: row.lon, country_code: row.country_code || "" };
    }
    const c = await geocodeWithFallback(buildQueries(row));
    if (!c) return null;
    return { lat: c.lat, lon: c.lon, country_code: row.country_code || c.country_code || "" };
  }

  const unit = {
    werke: [],
    kunden: [],
    alleMarker: [],
    selectedPoints: [],
    routeLine: null,
    tempSearchMarker: null,

    async init(){
      const [firmenRows, kundenRows] = await Promise.all([
        loadCsvAsObjects(sheetUrlFirmen),
        loadCsvAsObjects(sheetUrlKunden)
      ]);
      unit.werke = parseFirmen(firmenRows);
      unit.kunden = parseKunden(kundenRows);
      await unit.buildMap();
    },

    async buildMap(){
      unit.alleMarker = [];
      const bounds = L.latLngBounds();

      const firmGeo = await Promise.all(unit.werke.map(async (w)=>({ w, c: await coordForRow(w) })));
      for (const item of firmGeo){
        if(!item.c) continue;
        const { w, c } = item;

        const ap = activePriceForFirma(w);
        const initColor = colorForPrice(ap.price, ap.keinPreis);

        const circle = L.circleMarker([c.lat,c.lon],{
          radius:8,
          color:initColor,
          fillColor:initColor,
          fillOpacity:0.85
        });

        const markerObj = {
          type:"firma",
          marker: circle,
          firma:w.firma,
          plz:w.plz,
          ort:w.ort,
          land:w.land,
          zert:(w.zert||"").toLowerCase(),
          country_code:(c.country_code||""),
          prices: w.prices || {}
        };

        circle.bindTooltip("", {sticky:true})
          .on("tooltipopen", ()=> circle.getTooltip().setContent(tooltipHtmlFirma(markerObj)))
          .on("click",()=>unit.handleMarkerClick(markerObj.firma,c));

        unit.alleMarker.push(markerObj);
        bounds.extend([c.lat,c.lon]);
      }

      const kundGeo = await Promise.all(unit.kunden.map(async (k)=>({ k, c: await coordForRow(k) })));
      for (const item of kundGeo){
        if(!item.c) continue;
        const { k, c } = item;

        const place = `${k.plz ? k.plz+" " : ""}${k.ort || ""}`.trim();

        // ‚úÖ Zielpreis nur anzeigen, wenn Produkt wirklich Pelletabrieb ist + Zielpreis vorhanden
        const hatAbrieb = (k.produktNorm === "pelletabrieb") && isFinite(k.zielpreis);
        const zielHtml = hatAbrieb ? `<br><b>Zielpreis:</b> ${k.zielpreis.toFixed(2)} ‚Ç¨` : "";

        const m = L.marker([c.lat,c.lon],{icon:blauesDreieck})
          .bindTooltip(`<b>${k.name}</b><br>${place}${k.land ? "<br>" + k.land : ""}${zielHtml}`,{sticky:true})
          .on("click",()=>unit.handleMarkerClick(k.name,c));

        unit.alleMarker.push({
          type:"kunde",
          marker:m,
          name:k.name,
          produktNorm: k.produktNorm || "",
          zielpreis: k.zielpreis,
          country_code:(c.country_code||"")
        });

        bounds.extend([c.lat,c.lon]);
      }

      if(bounds.isValid()) map.fitBounds(bounds.pad(0.15));
      unit.updateLayers();
    },

    updateLayers(){
      unit.alleMarker.forEach(m=>{ if (m.marker && map.hasLayer(m.marker)) map.removeLayer(m.marker); });

      const selectedCountries = getSelectedCountries();
      const noCountryFilter = selectedCountries.length === 1 && selectedCountries[0] === "all";

      const sure = document.getElementById("chkSURE")?.checked ?? true;
      const pefc = document.getElementById("chkPEFC")?.checked ?? true;
      const ohne = document.getElementById("chkOhneZert")?.checked ?? true;

      const gruen  = document.getElementById("chkGruen")?.checked ?? true;
      const orange = document.getElementById("chkOrange")?.checked ?? true;
      const rot    = document.getElementById("chkRot")?.checked ?? true;
      const grau   = document.getElementById("chkGrau")?.checked ?? true;

      const kundenFlag = document.getElementById("chkKunden")?.checked ?? true;

      const showHacks = document.getElementById("chkHackschnitzel")?.checked ?? true;
      const showSaeg  = document.getElementById("chkSaegespaene")?.checked ?? true;
      const showSieb  = document.getElementById("chkSiebmaterial")?.checked ?? true;
      const showAbr   = document.getElementById("chkPelletabrieb")?.checked ?? true;

      for(const m of unit.alleMarker){
        if(m.type === "kunde"){
          if (kundenFlag) {
            if (noCountryFilter || (m.country_code && selectedCountries.includes(m.country_code))) map.addLayer(m.marker);
          }
          continue;
        }

        const hasH = m.prices?.hackschnitzel !== undefined;
        const hasS = m.prices?.saegespaene !== undefined;
        const hasM = m.prices?.siebmaterial !== undefined;
        const hasA = m.prices?.pelletabrieb !== undefined;

        if (!showHacks && !showSaeg && !showSieb && !showAbr) continue;
        if (!((showHacks && hasH) || (showSaeg && hasS) || (showSieb && hasM) || (showAbr && hasA))) continue;

        const z = (m.zert || "").toLowerCase().trim();
        let zertOK = false;
        if (z.includes("sure") && sure) zertOK = true;
        if (z.includes("pefc") && pefc) zertOK = true;
        if (!z && ohne) zertOK = true;
        if (!zertOK) continue;

        if (!noCountryFilter) {
          if (!m.country_code || !selectedCountries.includes(m.country_code)) continue;
        }

        const ap = activePriceForFirma(m);
        const aktiveFarbe = colorForPrice(ap.price, ap.keinPreis);

        const isGruen  = aktiveFarbe === "green";
        const isOrange = aktiveFarbe === "orange";
        const isRot    = aktiveFarbe === "red";
        const isGrau   = aktiveFarbe === "#9e9e9e";

        let sichtbar = false;
        if(isGruen && gruen) sichtbar = true;
        if(isOrange && orange) sichtbar = true;
        if(isRot && rot) sichtbar = true;
        if(isGrau && grau) sichtbar = true;
        if(!sichtbar) continue;

        if (m.marker && m.marker.setStyle) m.marker.setStyle({ color: aktiveFarbe, fillColor: aktiveFarbe });
        map.addLayer(m.marker);
      }
    },

    handleMarkerClick(label,coord){
      unit.selectedPoints.push({label,coord});
      if(unit.selectedPoints.length===2){
        const [a,b]=unit.selectedPoints;
        unit.showRoute(a,b);
        unit.selectedPoints=[];
      }
    },

    async showRoute(a,b){
      const url = `https://router.project-osrm.org/route/v1/driving/${a.coord.lon},${a.coord.lat};${b.coord.lon},${b.coord.lat}?overview=full&geometries=geojson`;
      const res = await fetch(url);
      const data = await res.json();
      if(!(data.routes && data.routes.length)){
        alert("Keine Route gefunden!");
        return;
      }

      const route = data.routes[0];
      const distKm = route.distance / 1000;
      const distTxt = distKm.toFixed(1);

      const durationMin = route.duration / 60;
      const hours = Math.floor(durationMin/60);
      const minutes = Math.round(durationMin%60);
      const durationStr = hours>0?`${hours}h ${minutes}min`:`${minutes}min`;

      const coords = route.geometry.coordinates.map(c=>[c[1],c[0]]);

      const firmaObjA = unit.alleMarker.find(m => m.type==="firma" && m.firma === a.label);
      const firmaObjB = unit.alleMarker.find(m => m.type==="firma" && m.firma === b.label);
      const firmeneintrag = firmaObjA || firmaObjB;

      const kundeObjA = unit.alleMarker.find(m => m.type==="kunde" && m.name === a.label);
      const kundeObjB = unit.alleMarker.find(m => m.type==="kunde" && m.name === b.label);
      const kundeneintrag = kundeObjA || kundeObjB;

      const preisH = firmeneintrag?.prices?.hackschnitzel;
      const preisS = firmeneintrag?.prices?.saegespaene;
      const preisM = firmeneintrag?.prices?.siebmaterial;
      const ekAbr  = firmeneintrag?.prices?.pelletabrieb;

      const showHacks = document.getElementById("chkHackschnitzel")?.checked ?? true;
      const showSaeg  = document.getElementById("chkSaegespaene")?.checked ?? true;
      const showSieb  = document.getElementById("chkSiebmaterial")?.checked ?? true;
      const showAbr   = document.getElementById("chkPelletabrieb")?.checked ?? true;

      const totalH = (showHacks && isFinite(preisH) && preisH > 0) ? calcHackschnitzel(preisH, distKm) : null;
      const totalS = (showSaeg  && isFinite(preisS) && preisS > 0) ? calcSaegespaene(preisS, distKm) : null;
      const totalM = (showSieb  && isFinite(preisM) && preisM > 0) ? calcSiebmaterial(preisM, distKm) : null;

      const totalAbr = (showAbr && isFinite(ekAbr) && ekAbr > 0) ? calcPelletabriebPreis(ekAbr, distKm) : null;

      let margeAbr = null;
      if (
        showAbr &&
        totalAbr !== null &&
        kundeneintrag &&
        kundeneintrag.produktNorm === "pelletabrieb" &&
        isFinite(kundeneintrag.zielpreis)
      ){
        margeAbr = calcPelletabriebMarge(kundeneintrag.zielpreis, ekAbr, distKm);
      }

      if(unit.routeLine) map.removeLayer(unit.routeLine);
      unit.routeLine = L.polyline(coords,{color:'blue',weight:5,opacity:0.8}).addTo(map);

      const mid = coords[Math.floor(coords.length/2)];

      const lineH = `<b>Hackschnitzel:</b> ${totalH !== null ? `<span style="color:green;font-size:1.05em">${totalH.toFixed(2)} ‚Ç¨</span>` : "‚Äì"}`;
      const lineS = `<b>S√§gesp√§ne:</b> ${totalS !== null ? `<span style="color:green;font-size:1.05em">${totalS.toFixed(2)} ‚Ç¨</span>` : "‚Äì"}`;
      const lineM = `<b>Siebmaterial:</b> ${totalM !== null ? `<span style="color:green;font-size:1.05em">${totalM.toFixed(2)} ‚Ç¨</span>` : "‚Äì"}`;

      const margeTxt = (margeAbr !== null && isFinite(margeAbr))
        ? ` <span style="opacity:.75">(Marge: ${margeAbr.toFixed(2)} ‚Ç¨)</span>`
        : "";

      const lineA = `<b>Pelletabrieb:</b> ${
        totalAbr !== null
          ? `<span style="color:green;font-size:1.05em">${totalAbr.toFixed(2)} ‚Ç¨</span>${margeTxt}`
          : "‚Äì"
      }`;

      const popupHtml = `
        <b>Route:</b> ${a.label} ‚Üî ${b.label}<br>
        <b>Entfernung:</b> ${distTxt} km<br>
        <b>Dauer:</b> ${durationStr}<br>
        <hr style="border:none;height:1px;background:#eee;margin:8px 0;">
        ${firmeneintrag
          ? `${lineH}<br>${lineS}<br>${lineM}<br>${lineA}`
          : `<b>Hinweis:</b> Keine Firma ausgew√§hlt ‚Äì keine Werkpreise verf√ºgbar.`}
      `;

      L.popup().setLatLng(mid).setContent(popupHtml).openOn(map);
      map.fitBounds(unit.routeLine.getBounds(),{padding:[40,40]});
    },

    async searchOrGeocode(query){
      const q = query.toLowerCase().trim();

      const hit = unit.alleMarker.find(m =>
        m.marker && m.marker.getTooltip && m.marker.getTooltip().getContent &&
        String(m.marker.getTooltip().getContent()).toLowerCase().includes(q)
      );

      if (hit) {
        const latlng = hit.marker.getLatLng();
        map.setView(latlng, 9);
        if (hit.marker.openTooltip) hit.marker.openTooltip();
        unit.handleMarkerClick(
          hit.type==="firma" ? hit.firma : hit.name,
          { lat: latlng.lat, lon: latlng.lng, country_code: hit.country_code || "" }
        );
        return;
      }

      const c = await geocodeWithFallback([query]);
      if(!c){ alert("Kein Treffer gefunden."); return; }

      if (unit.tempSearchMarker) map.removeLayer(unit.tempSearchMarker);
      unit.tempSearchMarker = L.marker([c.lat, c.lon], { icon: ortIcon })
        .bindTooltip(`<b>Ort:</b> ${query}`, {sticky:true})
        .addTo(map);

      map.setView([c.lat, c.lon], 10);
      unit.tempSearchMarker.openTooltip();

      unit.handleMarkerClick(`Ort: ${query}`, c);
    }
  };

  return unit;
}

/* =========================================================
   UNIT: PELLETS (Original)
========================================================= */

function createPelletsUnit(){
  const sheetUrlFirmen = "https://docs.google.com/spreadsheets/d/1f1oD1TlYWPRbD12d05yIGkqmXVygVt3ZHLk9U0bKoTs/export?format=csv";
  const sheetUrlKunden = "https://docs.google.com/spreadsheets/d/1DaiLyZbhJkdSQ1PHbJQmguIrDnGrrhiAVgJC4PJO8vA/export?format=csv&gid=0";

  function sackFilterAktiv(){
    const wantFireflies = document.getElementById("p_chkSackFireflies").checked;
    const want15kg      = document.getElementById("p_chkSack15kg").checked;
    return (wantFireflies || want15kg);
  }

  function tooltipHtmlFromMarker(m){
    const useSack = sackFilterAktiv();
    const preisNow = useSack && isFinite(m.preisSack) && m.preisSack > 0 ? m.preisSack : m.preis;
    const preisTxt = isFinite(preisNow) && preisNow > 0 ? `${preisNow.toFixed(2)} ‚Ç¨` : "‚Äì";
    const zertInfo = m.zert ? `<br><b>Zertifikat:</b> ${m.zert}` : "";
    const sackInfo = m.sack ? `<br><b>Sackware:</b> ${m.sack}` : "";
    return `<b>${m.firma}</b><br>${m.ort}<br>${preisTxt}${zertInfo}${sackInfo}`;
  }

  function parseFirmenWithHeader(rows){
    const lc = (s)=>String(s||"").toLowerCase();
    const keys = Object.keys(rows[0]||{});
    const findKey = (cands) => keys.find(k => cands.includes(lc(k)));

    const nameKey = findKey(["firma","name","werk"]) || keys[0];
    const ortKey  = findKey(["ort","stadt","location","standort","adresse"]) || keys[1];

    const preisKey = findKey(["preis","price","‚Ç¨/t","euro","euro_t","werkspreis"]);
    const sackPreisKey = findKey(["preis_sack","preis sack","sackpreis","bag_price","sackwarepreis","sackware preis","sackwarenpreis","preis_e"]);

    const zertKey = findKey(["zertifikate","zertifikat","zert","cert"]);
    const sackKey = findKey(["sackware","sack","bag","bagged"]);
    const landKey = findKey(["land","country"]);

    return rows
      .filter(x => (x?.[nameKey]||"").toString().trim() && (x?.[ortKey]||"").toString().trim())
      .map(x => {
        const { lat, lon } = extractLatLonFromRow(x, keys);
        const land = landKey ? (x?.[landKey]||"").toString().trim() : "";
        return {
          firma: (x[nameKey]||"").toString().trim(),
          ort: (x[ortKey]||"").toString().trim(),
          preis: parseFloatSmart(x?.[preisKey] ?? "0"),
          preisSack: parseFloatSmart(x?.[sackPreisKey] ?? "0"),
          zert: (x?.[zertKey]||"").toString().trim(),
          sack: (x?.[sackKey]||"").toString().trim(),
          land,
          country_code: countryCodeFromLand(land),
          lat, lon
        };
      });
  }

  function normalizePreise(daten){
    const g√ºltigeWerk = daten.filter(w => !isNaN(w.preis) && w.preis > 0);
    const g√ºltigeSack = daten.filter(w => !isNaN(w.preisSack) && w.preisSack > 0);
    const avgWerk = g√ºltigeWerk.length ? (g√ºltigeWerk.reduce((a,b)=>a+b.preis,0)/g√ºltigeWerk.length) : 0;
    const avgSack = g√ºltigeSack.length ? (g√ºltigeSack.reduce((a,b)=>a+b.preisSack,0)/g√ºltigeSack.length) : 0;

    return daten.map(w=>{
      if(isNaN(w.preis)||w.preis<=0){w.preis=avgWerk;w.keinPreisWerk=true;}else w.keinPreisWerk=false;
      if(isNaN(w.preisSack)||w.preisSack<=0){w.preisSack=avgSack;w.keinPreisSack=true;}else w.keinPreisSack=false;
      w.farbeWerk = colorForPrice(w.preis, w.keinPreisWerk);
      w.farbeSack = colorForPrice(w.preisSack, w.keinPreisSack);
      return w;
    });
  }

  async function loadFirmen(){
    const res = await fetch(sheetUrlFirmen, {cache:"no-store"});
    const text = await res.text();
    const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
    const rows = (parsed.data||[]).filter(r=>r && Object.keys(r).length);
    const daten = parseFirmenWithHeader(rows);
    return normalizePreise(daten);
  }

  async function loadKunden(){
    const res = await fetch(sheetUrlKunden, {cache:"no-store"});
    const text = await res.text();
    const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
    const rows = (parsed.data||[]).filter(r=>r && Object.keys(r).length);
    const keys = Object.keys(rows[0]||{});

    const headers = Object.keys(rows[0]||{});
    const nameKey = headers.find(h=>h.toLowerCase().includes("name"))||"name";
    const ortKey = headers.find(h=>["ort","adresse","standort","anschrift","stadt","location"].includes(h.toLowerCase()))||"ort";
    const loseKey = headers.find(h=>h.toLowerCase()==="lose") || "lose";
    const sackKey = headers.find(h=>h.toLowerCase()==="sackware") || "sackware";
    const sonstKey = headers.find(h=>h.toLowerCase().includes("sonstige")) || "sonstige";
    const landKey = headers.find(h=>["land","country"].includes(h.toLowerCase()));

    return rows
      .map(x=>{
        const { lat, lon } = extractLatLonFromRow(x, keys);
        const land = landKey ? (x?.[landKey]||"").toString().trim() : "";
        return {
          name:(x[nameKey]||"").trim(),
          ort:(x[ortKey]||"").trim(),
          lose:(x[loseKey]||"").trim().toLowerCase(),
          sackware:(x[sackKey]||"").trim().toLowerCase(),
          sonstige:(x[sonstKey]||"").trim().toLowerCase(),
          land,
          country_code: countryCodeFromLand(land),
          lat, lon
        };
      })
      .filter(x=>x.name && x.ort);
  }

  async function coordForRow(row){
    if (isFinite(row.lat) && isFinite(row.lon)) {
      return { lat: row.lat, lon: row.lon, country_code: row.country_code || "" };
    }
    const c = await geocodeOnce(row.ort || row.name || "");
    if (!c) return null;
    return { lat: c.lat, lon: c.lon, country_code: row.country_code || c.country_code || "" };
  }

  const unit = {
    werke: [],
    kunden: [],
    alleMarker: [],
    selectedPoints: [],
    routeLine: null,

    async init(){
      const [firmen, kunden] = await Promise.all([loadFirmen(), loadKunden()]);
      unit.werke = firmen;
      unit.kunden = kunden;
      await unit.buildMap();
    },

    async buildMap(){
      unit.alleMarker = [];
      const bounds = L.latLngBounds();

      for(const w of unit.werke){
        const c = await coordForRow(w);
        if(!c) continue;

        const farbeInit = sackFilterAktiv() ? w.farbeSack : w.farbeWerk;

        const m = L.circleMarker([c.lat,c.lon],{radius:8,color:farbeInit,fillColor:farbeInit,fillOpacity:0.85})
          .bindTooltip("", {sticky:true})
          .on("tooltipopen", () => {
            m.getTooltip().setContent( tooltipHtmlFromMarker({
              firma:w.firma, ort:w.ort,
              preis:w.preis, preisSack:w.preisSack,
              zert:(w.zert||""),
              sack:(w.sack||""),
              country_code: (c.country_code || "")
            }));
          })
          .on("click",()=>unit.handleMarkerClick(w.firma,c));

        unit.alleMarker.push({
          type:"firma",
          marker:m,
          firma:w.firma,
          ort:w.ort,
          preis:w.preis,
          preisSack:w.preisSack,
          farbeWerk:w.farbeWerk,
          farbeSack:w.farbeSack,
          zert:(w.zert||"").toLowerCase(),
          sack:(w.sack||""),
          country_code: (c.country_code || "")
        });

        bounds.extend([c.lat,c.lon]);
      }

      for(const k of unit.kunden){
        const c = await coordForRow(k);
        if(!c) continue;

        const isSackOnly = (k.sackware === "ja") && (k.lose !== "ja");
        const isSonstige = (k.sonstige === "ja");

        let type = "kunde";
        let iconToUse = blauesDreieck;
        if (isSonstige) { type = "sonstige"; iconToUse = orangeDreieck; }
        else if (isSackOnly) { type = "sackkunde"; iconToUse = lilaDreieck; }

        const m = L.marker([c.lat,c.lon],{icon:iconToUse})
          .bindTooltip(`<b>${k.name}</b><br>${k.ort}`,{sticky:true})
          .on("click",()=>unit.handleMarkerClick(k.name,c));

        unit.alleMarker.push({
          type,
          marker:m,
          name: k.name,
          ort: k.ort,
          country_code: (c.country_code || "")
        });

        bounds.extend([c.lat,c.lon]);
      }

      if(bounds.isValid()) map.fitBounds(bounds.pad(0.15));
      unit.updateLayers();
    },

    updateLayers(){
      unit.alleMarker.forEach(m=>{ if (m.marker && map.hasLayer(m.marker)) map.removeLayer(m.marker); });

      const selectedCountries = getSelectedCountries();
      const noCountryFilter = selectedCountries.length === 1 && selectedCountries[0] === "all";

      const en   = document.getElementById("p_chkEnPlus").checked;
      const din  = document.getElementById("p_chkDINplus").checked;
      const sure = document.getElementById("p_chkSURE").checked;
      const cpp  = document.getElementById("p_chkCPP").checked;
      const ohne = document.getElementById("p_chkOhneZert").checked;

      const gruen  = document.getElementById("p_chkGruen").checked;
      const orange = document.getElementById("p_chkOrange").checked;
      const rot    = document.getElementById("p_chkRot").checked;
      const grau   = document.getElementById("p_chkGrau").checked;

      const kundenFlag = document.getElementById("p_chkKunden").checked;
      const sackKundenFlag = document.getElementById("p_chkSackKunden").checked;
      const sonstigeFlag = document.getElementById("p_chkSonstigeKunden").checked;

      const wantFireflies = document.getElementById("p_chkSackFireflies").checked;
      const want15kg      = document.getElementById("p_chkSack15kg").checked;
      const useSack       = (wantFireflies || want15kg);

      for(const m of unit.alleMarker){
        if(m.type === "kunde"){
          if (kundenFlag) {
            if (noCountryFilter || (m.country_code && selectedCountries.includes(m.country_code))) map.addLayer(m.marker);
          }
          continue;
        }
        if(m.type === "sackkunde"){
          if (sackKundenFlag) {
            if (noCountryFilter || (m.country_code && selectedCountries.includes(m.country_code))) map.addLayer(m.marker);
          }
          continue;
        }
        if(m.type === "sonstige"){
          if (sonstigeFlag) {
            if (noCountryFilter || (m.country_code && selectedCountries.includes(m.country_code))) map.addLayer(m.marker);
          }
          continue;
        }

        if (useSack) {
          const sNorm = (m.sack||"").toLowerCase().replace(/\s+/g,' ').trim();
          const hasFireflies = sNorm.includes("fireflies");
          const has15kg = sNorm.includes("15 kg") || sNorm.includes("15kg");
          if (wantFireflies && !want15kg && !hasFireflies) continue;
          if (want15kg && !wantFireflies && !has15kg) continue;
          if (wantFireflies && want15kg && !(hasFireflies || has15kg)) continue;
        }

        const z = m.zert || "";
        let zertOK = false;
        if(z.includes("enplus") && en) zertOK = true;
        if(z.includes("dinplus") && din) zertOK = true;
        if(z.includes("sure") && sure) zertOK = true;
        if(z.includes("cpp") && cpp) zertOK = true;
        if(!z && ohne) zertOK = true;
        if(!zertOK) continue;

        if (!noCountryFilter) {
          if (!m.country_code || !selectedCountries.includes(m.country_code)) continue;
        }

        const aktiveFarbe = useSack ? m.farbeSack : m.farbeWerk;

        const isGruen  = aktiveFarbe === "green";
        const isOrange = aktiveFarbe === "orange";
        const isRot    = aktiveFarbe === "red";
        const isGrau   = aktiveFarbe === "#9e9e9e";

        let sichtbar = false;
        if(isGruen && gruen) sichtbar = true;
        if(isOrange && orange) sichtbar = true;
        if(isRot && rot) sichtbar = true;
        if(isGrau && grau) sichtbar = true;
        if(!sichtbar) continue;

        m.marker.setStyle({color:aktiveFarbe, fillColor:aktiveFarbe});
        map.addLayer(m.marker);
      }
    },

    handleMarkerClick(label,coord){
      unit.selectedPoints.push({label,coord});
      if(unit.selectedPoints.length===2){
        const [a,b]=unit.selectedPoints;
        unit.showRoute(a,b);
        unit.selectedPoints=[];
      }
    },

    async showRoute(a,b){
      const url = `https://router.project-osrm.org/route/v1/driving/${a.coord.lon},${a.coord.lat};${b.coord.lon},${b.coord.lat}?overview=full&geometries=geojson`;
      const res = await fetch(url);
      const data = await res.json();
      if(!(data.routes && data.routes.length)){
        alert("Keine Route gefunden!");
        return;
      }

      const route = data.routes[0];
      const distKm = route.distance / 1000;
      const distTxt = distKm.toFixed(1);

      const durationMin = route.duration / 60;
      const hours = Math.floor(durationMin/60);
      const minutes = Math.round(durationMin%60);
      const durationStr = hours>0?`${hours}h ${minutes}min`:`${minutes}min`;

      const coords = route.geometry.coordinates.map(c=>[c[1],c[0]]);
      const useSack = sackFilterAktiv();

      const firmeneintrag = unit.werke.find(w => w.firma === a.label || w.firma === b.label);
      const firmenPreis = firmeneintrag ? (useSack ? firmeneintrag.preisSack : firmeneintrag.preis) : 0;

      // ‚úÖ km-Satz bleibt wie vorher (2.15/1.85), aber neue Struktur:
      // gesamt = (EK + (km*preisProKm/24)) * 1.05
      const preisProKm = distKm < 250 ? 2.15 : 1.85;
      const berechnung = (distKm * preisProKm) / 24;
      const gesamt = (((firmenPreis||0) + berechnung) * 1.05);

      if(unit.routeLine) map.removeLayer(unit.routeLine);
      unit.routeLine = L.polyline(coords,{color:'blue',weight:5,opacity:0.8}).addTo(map);

      const mid = coords[Math.floor(coords.length/2)];
      L.popup().setLatLng(mid).setContent(`
        <b>Route:</b> ${a.label} ‚Üî ${b.label}<br>
        <b>Entfernung:</b> ${distTxt} km<br>
        <b>Dauer:</b> ${durationStr}<br>
        <b>Preis pro km:</b> ${preisProKm.toFixed(2)} ‚Ç¨<br>
        <b>${useSack ? "Sackware-Preis" : "Werkspreis"}:</b> ${(firmenPreis||0).toFixed(2)} ‚Ç¨<br>
        <b>Gesamtkosten:</b> <span style="color:green;font-size:1.1em">${gesamt.toFixed(2)} ‚Ç¨</span>
      `).openOn(map);

      map.fitBounds(unit.routeLine.getBounds(),{padding:[40,40]});
    },

    async searchOrGeocode(query){
      const q = query.toLowerCase().trim();

      const matches = unit.alleMarker.filter(m => {
        const tooltipContent = (m.marker.getTooltip && m.marker.getTooltip().getContent)
          ? String(m.marker.getTooltip().getContent()).toLowerCase()
          : "";
        const name = (m.firma || m.name || "").toLowerCase();
        const ort  = (m.ort   || "").toLowerCase();
        return tooltipContent.includes(q) || name.includes(q) || ort.includes(q);
      });

      if (matches.length) {
        const bounds = L.latLngBounds();
        matches.forEach((m, idx) => {
          const latlng = m.marker.getLatLng();
          map.addLayer(m.marker);
          bounds.extend(latlng);
          if (idx === 0 && m.marker.openTooltip) m.marker.openTooltip();
        });
        if (bounds.isValid()) map.fitBounds(bounds.pad(0.2));
        return;
      }

      const c = await geocodeOnce(query);
      if(!c){ alert("Kein Treffer gefunden."); return; }

      const marker = L.marker([c.lat, c.lon], { icon: ortIcon })
        .bindTooltip(`<b>Ort:</b> ${query}`, {sticky:true})
        .addTo(map);
      marker.openTooltip();

      unit.selectedPoints = [{ label: query, coord: { lat: c.lat, lon: c.lon } }];
    }
  };

  return unit;
}
</script>

</body>
</html>
```
