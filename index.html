<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pelletwerke ‚Äì Europa Preiskarte</title>

  <!-- Leaflet & PapaParse -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html,body{height:100%;margin:0;}
    #map{width:100%;height:100%;}

    .legend, .cert-box{
      position:absolute;
      background:#fff;
      padding:8px 10px;
      border-radius:6px;
      box-shadow:0 2px 8px rgba(0,0,0,.12);
      font:14px/1.3 system-ui,Arial,sans-serif;
    }

    .cert-box{bottom:12px;left:12px;z-index:1000;}
    .legend{bottom:12px;right:12px;min-width:180px;z-index:3000;}

    .cert-box input[type="checkbox"],
    .legend input[type="checkbox"]{
      width:14px;height:14px;margin-right:5px;vertical-align:middle;
    }

    .search-box{
      position:absolute;
      top:12px;right:12px;
      z-index:1500;
      background:#fff;
      padding:8px 10px;
      border-radius:6px;
      box-shadow:0 2px 8px rgba(0,0,0,.15);
      font:14px system-ui,Arial,sans-serif;
      width:260px;
    }
    .search-box input{
      width:100%;
      padding:6px 8px;
      border:1px solid #ccc;
      border-radius:4px;
      outline:none;
      box-sizing:border-box;
      margin-left:4px;
    }

    .cert-box hr{
      border:none;height:1px;background:#eee;margin:6px 0;
    }

    .country-dropdown{position:relative;display:block;width:100%;margin-top:8px;}
    .country-dropdown-button{
      width:100%;
      background:#fff;
      border:1px solid #ccc;
      border-radius:4px;
      padding:4px 6px;
      text-align:left;
      cursor:pointer;
      box-sizing:border-box;
    }
    .country-dropdown-button:after{content:"‚ñæ";float:right;opacity:.6;}
    .country-dropdown-menu{
      position:absolute;
      top:110%;left:0;
      background:#fff;
      border:1px solid #ccc;
      border-radius:4px;
      box-shadow:0 2px 8px rgba(0,0,0,.12);
      z-index:4000;
      display:none;
      min-width:160px;
      max-height:260px;
      overflow-y:auto;
      padding:6px 8px;
      box-sizing:border-box;
    }
    .country-dropdown-menu label{display:block;cursor:pointer;margin-bottom:3px;}
  </style>
</head>
<body>

<div id="map"></div>

<!-- Suche + L√§nderfilter -->
<div class="search-box">
  üîç <input type="text" id="searchInput" placeholder="Firma, Kunde oder Ort suchen‚Ä¶"/>

  <b style="display:block;margin-top:6px;">Land / L√§nder filtern</b>
  <div class="country-dropdown" id="countryDropdown">
    <div class="country-dropdown-button" id="countryDropdownBtn">Alle L√§nder</div>
    <div class="country-dropdown-menu" id="countryDropdownMenu">
      <label><input type="checkbox" class="countryChk" value="all" checked> Alle</label>
      <label><input type="checkbox" class="countryChk" value="de"> Deutschland</label>
      <label><input type="checkbox" class="countryChk" value="at"> √ñsterreich</label>
      <label><input type="checkbox" class="countryChk" value="pl"> Polen</label>
      <label><input type="checkbox" class="countryChk" value="cz"> Tschechien</label>
      <label><input type="checkbox" class="countryChk" value="fr"> Frankreich</label>
      <label><input type="checkbox" class="countryChk" value="ch"> Schweiz</label>
      <label><input type="checkbox" class="countryChk" value="be"> Belgien</label>
      <label><input type="checkbox" class="countryChk" value="sk"> Slowakei</label>
    </div>
  </div>
</div>

<!-- Zertifikate + Produkt -->
<div class="cert-box">
  <b>Zertifikate</b><br>
  <label><input type="checkbox" id="chkEnPlus" checked> 1</label><br>
  <label><input type="checkbox" id="chkDINplus" checked> 2</label><br>
  <label><input type="checkbox" id="chkSURE" checked> 3</label><br>
  <label><input type="checkbox" id="chkCPP" checked> 4</label><br>
  <label><input type="checkbox" id="chkOhneZert" checked> Kein Zertifikat</label>
  <hr>
  <b>Produkt</b><br>
  <label><input type="checkbox" id="chkHackschnitzel" checked> Hackschnitzel</label><br>
  <label><input type="checkbox" id="chkSaegespaene" checked> S√§gesp√§ne</label>
</div>

<!-- Legende -->
<div class="legend">
  <b>Filter Farben</b><br>
  <label><input type="checkbox" id="chkGruen" checked> üü¢ ‚â§ 260 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkOrange" checked> üü† 260‚Äì285 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkRot" checked> üî¥ ‚â• 285 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkGrau" checked> ‚ö™ kein Preis</label><br>
  <label><input type="checkbox" id="chkKunden" checked> üî∑ Pelletwerk</label>
</div>

<script>
  // =======================
  // Karte
  // =======================
  const map = L.map("map").setView([51, 11], 5);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    minZoom: 4, maxZoom: 10, attribution: "&copy; OpenStreetMap"
  }).addTo(map);

  function colorForPrice(p, keinPreis) {
    if (keinPreis) return "#9e9e9e";
    if (!p || p <= 0 || isNaN(p)) return "#9e9e9e";
    if (p <= 260) return "green";
    if (p < 285) return "orange";
    return "red";
  }

  // =======================
  // GeoCache
  // =======================
  const geoCache = JSON.parse(localStorage.getItem("geoCacheProdukte_EU") || "{}");
  async function geocode(q) {
    if (geoCache[q] && geoCache[q].country_code) return geoCache[q];

    const r = await fetch(
      `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&q=${encodeURIComponent(q)}&limit=1&accept-language=de`
    );
    const d = await r.json();
    if (d.length) {
      const item = d[0];
      const obj = {
        lat: +item.lat,
        lon: +item.lon,
        country: item.address && item.address.country ? item.address.country : "",
        country_code: item.address && item.address.country_code ? item.address.country_code.toLowerCase() : ""
      };
      geoCache[q] = obj;
      localStorage.setItem("geoCacheProdukte_EU", JSON.stringify(geoCache));
      return obj;
    }
    console.warn("Kein Geocode-Treffer:", q);
    return null;
  }

  // Icons
  const blauesDreieck = L.divIcon({
    className: "custom-triangle",
    html: `<svg width="24" height="24" viewBox="0 0 24 24">
             <polygon points="12,2 22,22 2,22" fill="blue" stroke="black" stroke-width="1"/>
           </svg>`,
    iconAnchor: [12,22],
    popupAnchor: [0,-20]
  });

  // =======================
  // NEUE TABELLEN (CSV Export!)
  // =======================
  // Firmen: https://docs.google.com/spreadsheets/d/1GIBV-WAyaslfi175jpbif0bHw8YWAhriifM7CtDUB2k/edit?gid=0#gid=0
  const sheetUrlFirmen = "https://docs.google.com/spreadsheets/d/1GIBV-WAyaslfi175jpbif0bHw8YWAhriifM7CtDUB2k/export?format=csv&gid=0";

  // Kunden: https://docs.google.com/spreadsheets/d/148jjtRze9SmuFsDNRfoM_nwEih7GbCzOjMUQEAb78pg/edit?gid=0#gid=0
  const sheetUrlKunden = "https://docs.google.com/spreadsheets/d/148jjtRze9SmuFsDNRfoM_nwEih7GbCzOjMUQEAb78pg/export?format=csv&gid=0";

  let werke = [], kunden = [], alleMarker = [], selectedPoints = [], routeLine = null;

  function parseFirmenWithHeader(rows){
    const lc = (s)=>String(s||"").toLowerCase();
    const keys = Object.keys(rows[0]||{});
    const findKey = (cands) => keys.find(k => cands.includes(lc(k)));

    // passt zu deinem Screenshot: firma | ort | plz | land | produkt | preis
    const nameKey   = findKey(["firma","name","werk"]) || keys[0];
    const ortKey    = findKey(["ort","stadt","location","standort","adresse"]) || keys[1];
    const preisKey  = findKey(["preis","price","‚Ç¨/t","euro","euro_t","werkspreis","‚Ç¨/srm","preis_srm"]) || "preis";
    const zertKey   = findKey(["zertifikate","zertifikat","zert","cert"]);
    const produktKey= findKey(["produkt","produkte","product","products"]) || "produkt";

    return rows
      .filter(x => (x?.[nameKey]||"").toString().trim() && (x?.[ortKey]||"").toString().trim())
      .map(x => ({
        firma: (x[nameKey]||"").toString().trim(),
        ort: (x[ortKey]||"").toString().trim(),
        preis: parseFloat(String(x?.[preisKey] ?? "0").replace(",", ".")),
        zert: (x?.[zertKey]||"").toString().trim(),
        produkt: produktKey ? (x?.[produktKey] || "").toString().trim() : ""
      }));
  }

  function normalizePreise(daten){
    const g√ºltige = daten.filter(w => !isNaN(w.preis) && w.preis > 0);
    const avg = g√ºltige.length ? (g√ºltige.reduce((a,b)=>a+b.preis,0)/g√ºltige.length) : 0;

    return daten.map(w=>{
      if(isNaN(w.preis)||w.preis<=0){ w.preis=avg; w.keinPreis=true; } else w.keinPreis=false;
      w.farbe = colorForPrice(w.preis, w.keinPreis);
      return w;
    });
  }

  function tooltipHtmlFromMarker(m){
    const preisTxt = (isFinite(m.preis) && m.preis > 0) ? `${m.preis.toFixed(2)} ‚Ç¨` : "‚Äì";
    const zertInfo = m.zert ? `<br><b>Zertifikat:</b> ${m.zert}` : "";

    let produktTxt = "";
    if (m.dataset === "hackschnitzel") {
      produktTxt = "<br><b>Produkt:</b> Hackschnitzel";
      if (m.produkt) produktTxt += ` ‚Äì ${m.produkt}`;
    } else if (m.dataset === "saegespaene") {
      produktTxt = "<br><b>Produkt:</b> S√§gesp√§ne";
      if (m.produkt) produktTxt += ` ‚Äì ${m.produkt}`;
    }

    return `<b>${m.firma}</b><br>${m.ort}<br>${preisTxt}${zertInfo}${produktTxt}`;
  }

  function attachWerkInteractions(layer, w, c){
    layer
      .bindTooltip("", {sticky:true})
      .on("tooltipopen", () => {
        layer.getTooltip().setContent( tooltipHtmlFromMarker({
          firma:w.firma, ort:w.ort,
          preis:w.preis,
          zert:(w.zert||""),
          produkt:(w.produkt||""),
          dataset:w.dataset
        }));
      })
      .on("click",()=>handleMarkerClick(w.firma,c));
  }

  async function ladeDaten() {
    // Firmen laden (eine Tabelle, wir splitten √ºber Spalte "produkt")
    const firmenPromise = new Promise((resolve) => {
      Papa.parse(sheetUrlFirmen, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: (r) => {
          try{
            let daten = parseFirmenWithHeader((r.data || []).filter(x => x && Object.keys(x).length));
            daten = normalizePreise(daten);

            // Zuordnung: produkt enth√§lt "hackschnitzel" oder "s√§gesp√§ne"
            const mapped = daten.map(w => {
              const p = (w.produkt || "").toLowerCase();
              const isSaeg = p.includes("s√§gesp√§ne") || p.includes("saegespaene") || p.includes("s√§gespaene");
              const isHacks = p.includes("hackschnitzel");

              // Fallback: wenn produkt leer oder unbekannt -> Hackschnitzel (kannst du √§ndern)
              const dataset = isSaeg ? "saegespaene" : (isHacks ? "hackschnitzel" : "hackschnitzel");
              return { ...w, dataset, productType: dataset };
            });

            resolve(mapped);
          }catch(e){
            console.error("Parsing Fehler (Firmen):", e);
            resolve([]);
          }
        }
      });
    });

    // Kunden laden (Header flexibel: name/firma + ort)
    const kundenPromise = new Promise((resolve)=>{
      Papa.parse(sheetUrlKunden, {
        download:true,
        header:true,
        skipEmptyLines:true,
        complete:(r)=>{
          const rows = (r.data || []).filter(x => x && Object.keys(x).length);
          if (!rows.length) return resolve([]);

          const headers = Object.keys(rows[0]||{});
          const lc = s => String(s||"").toLowerCase();

          const nameKey =
            headers.find(h=>["name","kunde","kundenname","firma","unternehmen"].includes(lc(h))) ||
            headers.find(h=>lc(h).includes("name")) ||
            headers.find(h=>lc(h).includes("kunde")) ||
            headers[0];

          const ortKey =
            headers.find(h=>["ort","adresse","standort","anschrift","stadt","location"].includes(lc(h))) ||
            headers.find(h=>lc(h).includes("ort")) ||
            headers[1];

          const kundenDaten = rows
            .map(x=>({
              name:(x[nameKey]||"").toString().trim(),
              ort:(x[ortKey]||"").toString().trim()
            }))
            .filter(x=>x.name && x.ort);

          resolve(kundenDaten);
        }
      });
    });

    const [firmen, kundenDaten] = await Promise.all([firmenPromise, kundenPromise]);
    werke = firmen;
    kunden = kundenDaten;
  }

  async function buildMap(){
    alleMarker = [];
    const bounds = L.latLngBounds();

    for(const w of werke){
      const c = (geoCache[w.ort] && geoCache[w.ort].country_code) ? geoCache[w.ort] : await geocode(w.ort);
      if(!c) continue;

      const farbeInit = w.farbe;

      const circleMarker = L.circleMarker([c.lat,c.lon],{
        radius:8,
        color:farbeInit,
        fillColor:farbeInit,
        fillOpacity:0.85
      });

      attachWerkInteractions(circleMarker, w, c);

      alleMarker.push({
        type:"firma",
        marker: circleMarker,
        circleMarker,
        firma:w.firma,
        ort:w.ort,
        preis:w.preis,
        keinPreis:w.keinPreis,
        farbe:w.farbe,
        zert:(w.zert||"").toLowerCase(),
        produkt:(w.produkt||""),
        country_code: (c.country_code || ""),
        dataset: w.dataset,
        productType: w.productType
      });

      bounds.extend([c.lat,c.lon]);
    }

    for(const k of kunden){
      const c = (geoCache[k.ort] && geoCache[k.ort].country_code) ? geoCache[k.ort] : await geocode(k.ort);
      if(!c) continue;

      const m = L.marker([c.lat,c.lon],{icon:blauesDreieck})
        .bindTooltip(`<b>${k.name}</b><br>${k.ort}`,{sticky:true})
        .on("click",()=>handleMarkerClick(k.name,c));

      alleMarker.push({
        type:"kunde",
        marker:m,
        country_code: (c.country_code || "")
      });

      bounds.extend([c.lat,c.lon]);
    }

    if(bounds.isValid()) map.fitBounds(bounds.pad(0.15));
    updateLayers();
  }

  function getSelectedCountries() {
    const chks = document.querySelectorAll(".countryChk");
    const selected = [];
    chks.forEach(ch => { if (ch.checked) selected.push(ch.value); });
    if (selected.length === 0 || selected.includes("all")) return ["all"];
    return selected;
  }

  function updateCountryButtonLabel() {
    const btn = document.getElementById("countryDropdownBtn");
    if (!btn) return;

    const selected = getSelectedCountries();
    if (selected.length === 1 && selected[0] === "all") {
      btn.textContent = "Alle L√§nder";
    } else {
      const names = {de:"DE",at:"AT",pl:"PL",cz:"CZ",fr:"FR",ch:"CH",be:"BE",sk:"SK"};
      btn.textContent = selected.map(c => names[c] || c.toUpperCase()).join(", ");
    }
  }

  function updateLayers(){
    // remove
    alleMarker.forEach(m=>{
      if (m.marker && map.hasLayer(m.marker)) map.removeLayer(m.marker);
      if (m.circleMarker && map.hasLayer(m.circleMarker)) map.removeLayer(m.circleMarker);
    });

    const selectedCountries = getSelectedCountries();
    const noCountryFilter = selectedCountries.length === 1 && selectedCountries[0] === "all";

    // Zertifikate (logik bleibt: wir pr√ºfen weiterhin Text im Feld "zert")
    const en   = document.getElementById("chkEnPlus")?.checked ?? true;
    const din  = document.getElementById("chkDINplus")?.checked ?? true;
    const sure = document.getElementById("chkSURE")?.checked ?? true;
    const cpp  = document.getElementById("chkCPP")?.checked ?? true;
    const ohne = document.getElementById("chkOhneZert")?.checked ?? true;

    // Farben
    const gruen  = document.getElementById("chkGruen")?.checked ?? true;
    const orange = document.getElementById("chkOrange")?.checked ?? true;
    const rot    = document.getElementById("chkRot")?.checked ?? true;
    const grau   = document.getElementById("chkGrau")?.checked ?? true;

    // Kunden
    const kundenFlag = document.getElementById("chkKunden")?.checked ?? true;

    // Produkte
    const showHacks = document.getElementById("chkHackschnitzel")?.checked ?? true;
    const showSaeg  = document.getElementById("chkSaegespaene")?.checked ?? true;

    for(const m of alleMarker){
      if(m.type === "kunde"){
        if (kundenFlag) {
          if (noCountryFilter || (m.country_code && selectedCountries.includes(m.country_code))) {
            m.marker && map.addLayer(m.marker);
          }
        }
        continue;
      }

      if (m.productType === "hackschnitzel" && !showHacks) continue;
      if (m.productType === "saegespaene"   && !showSaeg)  continue;

      // Zertfilter
      const z = (m.zert || "");
      let zertOK = false;
      if(z.includes("enplus") && en) zertOK = true;
      if(z.includes("dinplus") && din) zertOK = true;
      if(z.includes("sure") && sure) zertOK = true;
      if(z.includes("cpp") && cpp) zertOK = true;
      if(!z && ohne) zertOK = true;
      if(!zertOK) continue;

      // L√§nderfilter
      if (!noCountryFilter) {
        if (!m.country_code || !selectedCountries.includes(m.country_code)) continue;
      }

      // Farbfilter
      const aktiveFarbe = m.farbe;
      const isGruen  = aktiveFarbe === "green";
      const isOrange = aktiveFarbe === "orange";
      const isRot    = aktiveFarbe === "red";
      const isGrau   = aktiveFarbe === "#9e9e9e";

      let sichtbar = false;
      if(isGruen && gruen) sichtbar = true;
      if(isOrange && orange) sichtbar = true;
      if(isRot && rot) sichtbar = true;
      if(isGrau && grau) sichtbar = true;
      if(!sichtbar) continue;

      const layerToUse = m.circleMarker || m.marker;

      if (layerToUse && layerToUse.setStyle) {
        layerToUse.setStyle({color:aktiveFarbe, fillColor:aktiveFarbe});
      }
      if (layerToUse && layerToUse.getTooltip) {
        layerToUse.getTooltip().setContent( tooltipHtmlFromMarker(m) );
      }

      m.marker = layerToUse;
      if (layerToUse) map.addLayer(layerToUse);
    }
  }

  function handleMarkerClick(label,coord){
    selectedPoints.push({label,coord});
    if(selectedPoints.length===2){
      const [a,b]=selectedPoints;
      showRoute(a,b);
      selectedPoints=[];
    }
  }

  // ROUTE (bleibt gleich)
  async function showRoute(a,b){
    const url = `https://router.project-osrm.org/route/v1/driving/${a.coord.lon},${a.coord.lat};${b.coord.lon},${b.coord.lat}?overview=full&geometries=geojson`;
    const res = await fetch(url);
    const data = await res.json();
    if(!(data.routes && data.routes.length)){
      alert("Keine Route gefunden!");
      return;
    }

    const route = data.routes[0];
    const distKm = route.distance / 1000;
    const dist = distKm.toFixed(1);
    const durationMin = route.duration / 60;
    const hours = Math.floor(durationMin/60);
    const minutes = Math.round(durationMin%60);
    const durationStr = hours>0?`${hours}h ${minutes}min`:`${minutes}min`;
    const coords = route.geometry.coordinates.map(c=>[c[1],c[0]]);

    const werkA = werke.find(w => w.firma === a.label);
    const werkB = werke.find(w => w.firma === b.label);
    const firmeneintrag = werkA || werkB;

    const firmenPreis = firmeneintrag ? (firmeneintrag.preis || 0) : 0;

    const preisProKm = distKm < 250 ? 2.15 : 1.85;
    const teilstrecke = distKm / 24;
    const berechnung = teilstrecke * preisProKm;
    const gesamt = (berechnung + (firmenPreis||0)) * 1.05;

    if(routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(coords,{color:'blue',weight:5,opacity:0.8}).addTo(map);

    const mid = coords[Math.floor(coords.length/2)];
    L.popup().setLatLng(mid).setContent(`
      <b>Route:</b> ${a.label} ‚Üî ${b.label}<br>
      <b>Entfernung:</b> ${dist} km<br>
      <b>Dauer:</b> ${durationStr}<br>
      <b>Preis pro km:</b> ${preisProKm.toFixed(2)} ‚Ç¨<br>
      <b>Werkspreis:</b> ${(firmenPreis||0).toFixed(2)} ‚Ç¨<br>
      <b>Gesamtkosten:</b> <span style="color:green;font-size:1.1em">${gesamt.toFixed(2)} ‚Ç¨</span>
    `).openOn(map);

    map.fitBounds(routeLine.getBounds(),{padding:[40,40]});
  }

  map.on('click', (e) => {
    const t = e.originalEvent && e.originalEvent.target;
    if (t && t.closest) {
      if (t.closest('.leaflet-marker-icon') ||
          t.closest('.leaflet-popup') ||
          t.closest('.leaflet-interactive')) {
        return;
      }
    }
    if (routeLine) {
      map.removeLayer(routeLine);
      routeLine = null;
    }
    selectedPoints = [];
    map.closePopup();
  });

  document.addEventListener("change", e => {
    if (e.target && e.target.matches('input[type="checkbox"]')) {
      if (e.target.classList.contains("countryChk")) {
        if (e.target.value === "all" && e.target.checked) {
          document.querySelectorAll(".countryChk").forEach(ch => {
            if (ch.value !== "all") ch.checked = false;
          });
        } else if (e.target.value !== "all" && e.target.checked) {
          const allChk = document.querySelector('.countryChk[value="all"]');
          if (allChk) allChk.checked = false;
        }
        updateCountryButtonLabel();
      }
      updateLayers();
    }
  });

  const countryBtn = document.getElementById("countryDropdownBtn");
  if (countryBtn) {
    countryBtn.addEventListener("click", () => {
      const menu = document.getElementById("countryDropdownMenu");
      if (!menu) return;
      menu.style.display = (menu.style.display === "block") ? "none" : "block";
    });
  }

  document.addEventListener("click", (e) => {
    const dd = document.getElementById("countryDropdown");
    const menu = document.getElementById("countryDropdownMenu");
    if (!dd || !menu) return;
    if (!dd.contains(e.target)) menu.style.display = "none";
  });

  const searchInput = document.getElementById("searchInput");
  if (searchInput) {
    searchInput.addEventListener("keydown", e => {
      if(e.key === "Enter"){
        const query = e.target.value.toLowerCase().trim();
        if(!query) return;

        const treffer = alleMarker.find(m =>
          m.marker &&
          m.marker.getTooltip &&
          m.marker.getTooltip().getContent &&
          String(m.marker.getTooltip().getContent()).toLowerCase().includes(query)
        );

        if(treffer){
          const latlng = treffer.marker.getLatLng();
          map.setView(latlng,9);
          treffer.marker.openTooltip();
        } else alert("Kein Treffer gefunden.");
      }
    });
  }

  (async ()=>{
    await ladeDaten();
    await buildMap();
  })();
</script>

</body>
</html>
