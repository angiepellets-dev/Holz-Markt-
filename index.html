<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pelletwerke ‚Äì Europa Preiskarte</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html,body{height:100%;margin:0;}
    #map{width:100%;height:100%;}

    .legend, .cert-box{
      position:absolute;background:#fff;padding:8px 10px;border-radius:6px;
      box-shadow:0 2px 8px rgba(0,0,0,.12);
      font:14px/1.3 system-ui,Arial,sans-serif;
    }
    .cert-box{bottom:12px;left:12px;z-index:1000;}
    .legend{bottom:12px;right:12px;min-width:180px;z-index:3000;}

    .cert-box input[type="checkbox"],
    .legend input[type="checkbox"]{width:14px;height:14px;margin-right:5px;vertical-align:middle;}

    .search-box{
      position:absolute;top:12px;right:12px;z-index:1500;background:#fff;
      padding:8px 10px;border-radius:6px;box-shadow:0 2px 8px rgba(0,0,0,.15);
      font:14px system-ui,Arial,sans-serif;width:280px;
    }
    .search-box input[type="text"]{
      width:100%;padding:6px 8px;border:1px solid #ccc;border-radius:4px;
      outline:none;box-sizing:border-box;margin-left:4px;
    }
    .search-hint{margin-top:6px;font-size:12px;opacity:.75;line-height:1.25;}

    .cert-box hr{border:none;height:1px;background:#eee;margin:6px 0;}

    .country-dropdown{position:relative;display:block;width:100%;margin-top:8px;}
    .country-dropdown-button{
      width:100%;background:#fff;border:1px solid #ccc;border-radius:4px;
      padding:4px 6px;text-align:left;cursor:pointer;box-sizing:border-box;
    }
    .country-dropdown-button:after{content:"‚ñæ";float:right;opacity:.6;}
    .country-dropdown-menu{
      position:absolute;top:110%;left:0;background:#fff;border:1px solid #ccc;
      border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,.12);
      z-index:4000;display:none;min-width:160px;max-height:260px;overflow-y:auto;
      padding:8px 10px;box-sizing:border-box;
    }
    .country-dropdown-menu label{
      display:flex;align-items:center;gap:8px;margin:6px 0;cursor:pointer;user-select:none;
    }
    .country-dropdown-menu label input[type="checkbox"]{margin:0;width:14px;height:14px;flex:0 0 auto;}
  </style>
</head>
<body>

<div id="map"></div>

<!-- Suche + L√§nderfilter -->
<div class="search-box">
  üîç <input type="text" id="searchInput" placeholder="Firma, Kunde oder Ort/Adresse suchen‚Ä¶"/>
  <div class="search-hint"></div>

  <b style="display:block;margin-top:8px;">Land / L√§nder filtern</b>
  <div class="country-dropdown" id="countryDropdown">
    <div class="country-dropdown-button" id="countryDropdownBtn">Alle L√§nder</div>
    <div class="country-dropdown-menu" id="countryDropdownMenu">
      <label><input type="checkbox" class="countryChk" value="all" checked> Alle</label>
      <label><input type="checkbox" class="countryChk" value="be"> Belgien</label>
      <label><input type="checkbox" class="countryChk" value="dk"> D√§nemark</label>
      <label><input type="checkbox" class="countryChk" value="de"> Deutschland</label>
      <label><input type="checkbox" class="countryChk" value="ee"> Estland</label>
      <label><input type="checkbox" class="countryChk" value="fi"> Finnland</label>
      <label><input type="checkbox" class="countryChk" value="fr"> Frankreich</label>
      <label><input type="checkbox" class="countryChk" value="it"> Italien</label>
      <label><input type="checkbox" class="countryChk" value="lv"> Lettland</label>
      <label><input type="checkbox" class="countryChk" value="lt"> Litauen</label>
      <label><input type="checkbox" class="countryChk" value="nl"> Niederlande</label>
      <label><input type="checkbox" class="countryChk" value="at"> √ñsterreich</label>
      <label><input type="checkbox" class="countryChk" value="pl"> Polen</label>
      <label><input type="checkbox" class="countryChk" value="se"> Schweden</label>
      <label><input type="checkbox" class="countryChk" value="ch"> Schweiz</label>
      <label><input type="checkbox" class="countryChk" value="sk"> Slowakei</label>
      <label><input type="checkbox" class="countryChk" value="cz"> Tschechien</label>
      <label><input type="checkbox" class="countryChk" value="gb"> United Kingdom</label>
    </div>
  </div>
</div>

<!-- Zertifikate + Produkt -->
<div class="cert-box">
  <b>Zertifikate</b><br>
  <label><input type="checkbox" id="chkCertSURE" checked> 1 (SURE)</label><br>
  <label><input type="checkbox" id="chkCertPEFC" checked> 2 (PEFC)</label><br>
  <label><input type="checkbox" id="chkOhneZert" checked> Kein Zertifikat</label>
  <hr>
  <b>Produkt</b><br>
  <label><input type="checkbox" id="chkHackschnitzel" checked> Hackschnitzel</label><br>
  <label><input type="checkbox" id="chkSaegespaene" checked> S√§gesp√§ne</label><br>
  <label><input type="checkbox" id="chkSiebmaterial" checked> Siebmaterial</label>
</div>

<!-- Legende -->
<div class="legend">
  <b>Filter Farben</b><br>
  <label><input type="checkbox" id="chkGruen" checked> üü¢ ‚â§ 260 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkOrange" checked> üü† 260‚Äì285 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkRot" checked> üî¥ ‚â• 285 ‚Ç¨</label><br>
  <label><input type="checkbox" id="chkGrau" checked> ‚ö™ kein Preis</label><br>
  <label><input type="checkbox" id="chkKunden" checked> üî∑ Pelletwerk</label>
</div>

<script>
  // =======================
  // Karte
  // =======================
  const map = L.map("map", { maxZoom: 19 }).setView([51, 11], 5);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    minZoom: 4, maxZoom: 19, attribution: "&copy; OpenStreetMap"
  }).addTo(map);

  function colorForPrice(p, keinPreis) {
    if (keinPreis) return "#9e9e9e";
    if (!p || p <= 0 || isNaN(p)) return "#9e9e9e";
    if (p <= 260) return "green";
    if (p < 285) return "orange";
    return "red";
  }

  // =======================
  // GeoCache + Geocode
  // =======================
  const GEO_CACHE_KEY = "geoCacheProdukte_EU_v3";
  const geoCache = JSON.parse(localStorage.getItem(GEO_CACHE_KEY) || "{}");
  const inFlight = new Map();

  async function geocodeOnce(q) {
    if (geoCache[q] && geoCache[q].country_code) return geoCache[q];
    if (inFlight.has(q)) return inFlight.get(q);

    const p = (async ()=>{
      const r = await fetch(
        `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&q=${encodeURIComponent(q)}&limit=1&accept-language=de`,
        { headers: { "Accept": "application/json" } }
      );
      const d = await r.json();
      if (d && d.length) {
        const item = d[0];
        const obj = {
          lat: +item.lat,
          lon: +item.lon,
          country: item.address && item.address.country ? item.address.country : "",
          country_code: item.address && item.address.country_code ? item.address.country_code.toLowerCase() : ""
        };
        geoCache[q] = obj;
        localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(geoCache));
        return obj;
      }
      return null;
    })();

    inFlight.set(q, p);
    try { return await p; }
    finally { inFlight.delete(q); }
  }

  async function geocodeWithFallback(queries){
    for (const q of queries) {
      const qq = (q || "").trim();
      if (!qq) continue;
      const res = await geocodeOnce(qq);
      if (res) return res;
    }
    return null;
  }

  // =======================
  // Icons
  // =======================
  const blauesDreieck = L.divIcon({
    className: "custom-triangle",
    html: `<svg width="24" height="24" viewBox="0 0 24 24">
             <polygon points="12,2 22,22 2,22" fill="blue" stroke="black" stroke-width="1"/>
           </svg>`,
    iconAnchor: [12,22],
    popupAnchor: [0,-20]
  });

  const ortIcon = L.divIcon({
    className: "custom-place",
    html: `<svg width="26" height="26" viewBox="0 0 24 24">
      <path d="M12 2c-3.3 0-6 2.7-6 6 0 4.5 6 14 6 14s6-9.5 6-14c0-3.3-2.7-6-6-6z" fill="#111" stroke="#fff" stroke-width="1.2"/>
      <circle cx="12" cy="8" r="2.4" fill="#fff"/>
    </svg>`,
    iconAnchor: [13,24],
    popupAnchor: [0,-18]
  });

  // =======================
  // Tabellen Links
  // =======================
  const sheetUrlFirmen = "https://docs.google.com/spreadsheets/d/1GIBV-WAyaslfi175jpbif0bHw8YWAhriifM7CtDUB2k/gviz/tq?tqx=out:csv&gid=0";
  const sheetUrlKunden = "https://docs.google.com/spreadsheets/d/148jjtRze9SmuFsDNRfoM_nwEih7GbCzOjMUQEAb78pg/gviz/tq?tqx=out:csv&gid=0";

  async function loadCsvAsObjects(url){
    const res = await fetch(url, { cache: "no-store" });
    const text = await res.text();
    const head = text.slice(0, 150).toLowerCase();
    if (head.includes("<html") || head.includes("<!doctype")) throw new Error("Google liefert HTML statt CSV.");
    const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
    return (parsed.data || []).filter(r => r && Object.keys(r).length);
  }

  // =======================
  // Produkt + Zertifikate
  // =======================
  function normProduktName(p){
    const s = (p || "").toLowerCase();
    if (s.includes("hackschnitzel")) return "hackschnitzel";
    if (s.includes("s√§gesp√§ne") || s.includes("saegespaene") || s.includes("s√§gespaene") || s.includes("saegesp√§ne")) return "saegespaene";
    if (s.includes("siebmaterial")) return "siebmaterial";
    return "";
  }

  function normalizeCertString(s){
    return String(s||"")
      .replace(/;/g, ",")
      .toLowerCase()
      .replace(/\s+/g, " ")
      .trim();
  }
  function certHasSure(cert){ return normalizeCertString(cert).includes("sure"); }
  function certHasPefc(cert){ return normalizeCertString(cert).includes("pefc"); }
  function prettyCertList(cert){
    const c = normalizeCertString(cert);
    const list = [];
    if (c.includes("sure")) list.push("SURE");
    if (c.includes("pefc")) list.push("PEFC");
    return list.join(", ");
  }

  // =======================
  // ‚úÖ Preis-Berechnungen
  // =======================
  // Hackschnitzel / S√§gesp√§ne:
  // <200km: ((F*90)/90 + ((2.15*km)/90))*1.05
  // >=200km: ((F*90)/90 + ((1.85*km)/90))*1.05
  function calcHolzProdukt(ek, km){
    const F = (isFinite(ek) && ek > 0) ? ek : null;
    if (F === null) return null;

    const G = 90;
    const J = 90;
    const K = 1.05;
    const H = (km < 200) ? 2.15 : 1.85;
    const I = km;

    const value = (((F * G) / G) + ((H * I) / J)) * K;
    return value;
  }

  // Siebmaterial:
  // =(((EK*21,50)+(1,85*km))/11,8)*1,05
  function calcSiebmaterial(ek, km){
    const EK = (isFinite(ek) && ek > 0) ? ek : null;
    if (EK === null) return null;

    const TONNE = 21.50;
    const KMSATZ = 1.85;
    const ATRO = 11.8;
    const MARGE = 1.05;

    const value = ((((EK * TONNE) + (KMSATZ * km)) / ATRO) * MARGE);
    return value;
  }

  // F√ºr Markerfarbe: g√ºnstigster aktiver berechneter Preis
  function activeCalcPriceForFirma(w, kmForColor=250){
    const showH = document.getElementById("chkHackschnitzel")?.checked ?? true;
    const showS = document.getElementById("chkSaegespaene")?.checked ?? true;
    const showM = document.getElementById("chkSiebmaterial")?.checked ?? true;

    const list = [];

    if (showH && w.prices?.hackschnitzel !== undefined) {
      const v = calcHolzProdukt(w.prices.hackschnitzel, kmForColor);
      if (v !== null) list.push(v);
    }
    if (showS && w.prices?.saegespaene !== undefined) {
      const v = calcHolzProdukt(w.prices.saegespaene, kmForColor);
      if (v !== null) list.push(v);
    }
    if (showM && w.prices?.siebmaterial !== undefined) {
      const v = calcSiebmaterial(w.prices.siebmaterial, kmForColor);
      if (v !== null) list.push(v);
    }

    if (!list.length) return { price: 0, keinPreis: true };
    return { price: Math.min(...list), keinPreis: false };
  }

  // =======================
  // Parser Firmen/Kunden
  // =======================
  function parseFirmen(rows){
    const lc = (s)=>String(s||"").toLowerCase().trim();
    const keys = Object.keys(rows[0]||{});
    const findKey = (cands) => keys.find(k => cands.includes(lc(k)));

    const firmaKey = findKey(["firma","name","werk"]) || "firma";
    const plzKey   = findKey(["plz","zip","postcode","postleitzahl"]) || "plz";
    const ortKey   = findKey(["ort","stadt","location","standort","adresse"]) || "ort";
    const landKey  = findKey(["land","country"]) || "land";

    const zertKeyHeader = keys.find(k => ["zertifikate","zertifikat","zert","cert"].includes(lc(k)));
    const zertKeyQ = keys.find(k => lc(k) === "q");
    const zertKey = zertKeyHeader || zertKeyQ;

    const produktKeys = keys.filter(k => lc(k).startsWith("produkt"));
    const preisKeys   = keys.filter(k => lc(k).startsWith("preis"));

    return rows.map(x => {
      const prices = {};
      const pairs = Math.max(produktKeys.length, preisKeys.length);

      for (let i=0; i<pairs; i++){
        const pKey = produktKeys[i];
        const rKey = preisKeys[i];

        const prodRaw = pKey ? (x?.[pKey] || "").toString().trim() : "";
        const priceRaw = rKey ? (x?.[rKey] ?? "").toString() : "";

        const prodNorm = normProduktName(prodRaw);
        const priceVal = parseFloat(String(priceRaw).replace(",", "."));

        if (prodNorm && isFinite(priceVal) && priceVal > 0) prices[prodNorm] = priceVal;
        else if (prodNorm && !(prodNorm in prices)) prices[prodNorm] = 0;
      }

      return {
        firma: (x[firmaKey]||"").toString().trim(),
        plz: (x[plzKey]||"").toString().trim(),
        ort: (x[ortKey]||"").toString().trim(),
        land:(x[landKey]||"").toString().trim(),
        prices,
        zert: zertKey ? (x?.[zertKey]||"").toString().trim() : ""
      };
    }).filter(w => w.firma && (w.plz || w.ort));
  }

  function parseKunden(rows){
    const lc = (s)=>String(s||"").toLowerCase().trim();
    const keys = Object.keys(rows[0]||{});
    const findKey = (cands) => keys.find(k => cands.includes(lc(k)));

    const kundeKey = findKey(["kunde","name","firma","unternehmen"]) || "kunde";
    const plzKey   = findKey(["plz","zip","postcode","postleitzahl"]) || "plz";
    const ortKey   = findKey(["ort","stadt","location","adresse","standort"]) || "ort";
    const landKey  = findKey(["land","country"]) || "land";

    return rows.map(x => ({
      name: (x[kundeKey]||"").toString().trim(),
      plz: (x[plzKey]||"").toString().trim(),
      ort: (x[ortKey]||"").toString().trim(),
      land: (x[landKey]||"").toString().trim()
    })).filter(k => k.name && (k.plz || k.ort));
  }

  // Tooltip Firma (zeigt Zertifikate + EKs, aber ohne Rechnungsformel)
  function tooltipHtmlFirma(m){
    const landInfo = m.land ? `<br><b>Land:</b> ${m.land}` : "";
    const place = `${m.plz ? m.plz+" " : ""}${m.ort || ""}`.trim();

    const pH = m.prices?.hackschnitzel;
    const pS = m.prices?.saegespaene;
    const pM = m.prices?.siebmaterial;

    const lineH = (pH !== undefined) ? `<b>Hackschnitzel (EK):</b> ${isFinite(pH) && pH>0 ? pH.toFixed(2)+" ‚Ç¨" : "‚Äì"}` : "";
    const lineS = (pS !== undefined) ? `<b>S√§gesp√§ne (EK):</b> ${isFinite(pS) && pS>0 ? pS.toFixed(2)+" ‚Ç¨" : "‚Äì"}` : "";
    const lineM = (pM !== undefined) ? `<b>Siebmaterial (EK):</b> ${isFinite(pM) && pM>0 ? pM.toFixed(2)+" ‚Ç¨" : "‚Äì"}` : "";

    const certPretty = prettyCertList(m.zert);
    const certLine = certPretty ? `<br><b>Zertifikat:</b> ${certPretty}` : (m.zert ? `<br><b>Zertifikat:</b> ${m.zert}` : "");

    const lines = [lineH,lineS,lineM].filter(Boolean).join("<br>");
    return `<b>${m.firma}</b><br>${place}${landInfo}${certLine}${lines ? "<br>"+lines : ""}`;
  }

  // =======================
  // State
  // =======================
  let werke = [], kunden = [], alleMarker = [], selectedPoints = [], routeLine = null;
  let tempSearchMarker = null;

  function buildQueries(obj){
    const plz = (obj.plz||"").trim();
    const ort = (obj.ort||"").trim();
    const land = (obj.land||"").trim();

    const q1 = `${plz} ${ort}, ${land}`.replace(/\s+/g," ").trim();
    const q2 = `${plz} ${ort}`.replace(/\s+/g," ").trim();
    const q3 = `${ort}, ${land}`.replace(/\s+/g," ").trim();
    const q4 = `${ort}`.trim();
    return [q1,q2,q3,q4];
  }

  async function ladeDaten(){
    const [firmenRows, kundenRows] = await Promise.all([
      loadCsvAsObjects(sheetUrlFirmen),
      loadCsvAsObjects(sheetUrlKunden)
    ]);
    werke = parseFirmen(firmenRows);
    kunden = parseKunden(kundenRows);
  }

  async function buildMap(){
    alleMarker = [];
    const bounds = L.latLngBounds();

    const firmGeo = await Promise.all(werke.map(async (w)=>({ w, c: await geocodeWithFallback(buildQueries(w)) })));
    for (const item of firmGeo){
      if(!item.c) continue;
      const { w, c } = item;

      const ap = activeCalcPriceForFirma(w, 250);
      const initColor = colorForPrice(ap.price, ap.keinPreis);

      const circle = L.circleMarker([c.lat,c.lon],{
        radius:8,
        color:initColor,
        fillColor:initColor,
        fillOpacity:0.85
      });

      const markerObj = {
        type:"firma",
        marker: circle,
        firma:w.firma,
        plz:w.plz,
        ort:w.ort,
        land:w.land,
        zert:(w.zert||""),
        zert_norm: normalizeCertString(w.zert||""),
        country_code:(c.country_code||""),
        prices: w.prices || {}
      };

      circle.bindTooltip("", {sticky:true})
        .on("tooltipopen", ()=> circle.getTooltip().setContent(tooltipHtmlFirma(markerObj)))
        .on("click",()=>handleMarkerClick(markerObj.firma,c));

      alleMarker.push(markerObj);
      bounds.extend([c.lat,c.lon]);
    }

    const kundGeo = await Promise.all(kunden.map(async (k)=>({ k, c: await geocodeWithFallback(buildQueries(k)) })));
    for (const item of kundGeo){
      if(!item.c) continue;
      const { k, c } = item;

      const place = `${k.plz ? k.plz+" " : ""}${k.ort || ""}`.trim();
      const m = L.marker([c.lat,c.lon],{icon:blauesDreieck})
        .bindTooltip(`<b>${k.name}</b><br>${place}${k.land ? "<br>" + k.land : ""}`,{sticky:true})
        .on("click",()=>handleMarkerClick(k.name,c));

      alleMarker.push({ type:"kunde", marker:m, country_code:(c.country_code||"") });
      bounds.extend([c.lat,c.lon]);
    }

    if(bounds.isValid()) map.fitBounds(bounds.pad(0.15));
    updateLayers();
  }

  // =======================
  // Filter / Layer
  // =======================
  function getSelectedCountries() {
    const chks = document.querySelectorAll(".countryChk");
    const selected = [];
    chks.forEach(ch => { if (ch.checked) selected.push(ch.value); });
    if (selected.length === 0 || selected.includes("all")) return ["all"];
    return selected;
  }

  function updateCountryButtonLabel() {
    const btn = document.getElementById("countryDropdownBtn");
    if (!btn) return;

    const selected = getSelectedCountries();
    if (selected.length === 1 && selected[0] === "all") btn.textContent = "Alle L√§nder";
    else {
      const names = {
        de:"DE", at:"AT", pl:"PL", cz:"CZ", fr:"FR", ch:"CH", be:"BE", sk:"SK",
        dk:"DK", ee:"EE", fi:"FI", it:"IT", lv:"LV", lt:"LT", nl:"NL", se:"SE", gb:"GB"
      };
      btn.textContent = selected.map(c => names[c] || c.toUpperCase()).join(", ");
    }
  }

  function updateLayers(){
    alleMarker.forEach(m=>{
      if (m.marker && map.hasLayer(m.marker)) map.removeLayer(m.marker);
    });

    const selectedCountries = getSelectedCountries();
    const noCountryFilter = selectedCountries.length === 1 && selectedCountries[0] === "all";

    const wantSURE = document.getElementById("chkCertSURE")?.checked ?? true;
    const wantPEFC = document.getElementById("chkCertPEFC")?.checked ?? true;
    const wantOHNE = document.getElementById("chkOhneZert")?.checked ?? true;

    const gruen  = document.getElementById("chkGruen")?.checked ?? true;
    const orange = document.getElementById("chkOrange")?.checked ?? true;
    const rot    = document.getElementById("chkRot")?.checked ?? true;
    const grau   = document.getElementById("chkGrau")?.checked ?? true;

    const kundenFlag = document.getElementById("chkKunden")?.checked ?? true;

    const showHacks = document.getElementById("chkHackschnitzel")?.checked ?? true;
    const showSaeg  = document.getElementById("chkSaegespaene")?.checked ?? true;
    const showSieb  = document.getElementById("chkSiebmaterial")?.checked ?? true;

    for(const m of alleMarker){
      if(m.type === "kunde"){
        if (kundenFlag) {
          if (noCountryFilter || (m.country_code && selectedCountries.includes(m.country_code))) map.addLayer(m.marker);
        }
        continue;
      }

      // Produkt-Existenz
      const hasH = m.prices?.hackschnitzel !== undefined;
      const hasS = m.prices?.saegespaene !== undefined;
      const hasM = m.prices?.siebmaterial !== undefined;

      if (!showHacks && !showSaeg && !showSieb) continue;
      if ((showHacks || showSaeg || showSieb) && !(
        (showHacks && hasH) || (showSaeg && hasS) || (showSieb && hasM)
      )) continue;

      // Zertifikats-Filter
      const certNorm = normalizeCertString(m.zert || "");
      const hasSure = certHasSure(certNorm);
      const hasPefc = certHasPefc(certNorm);
      const hasNone = !certNorm;

      let certOK = false;
      if (hasSure && wantSURE) certOK = true;
      if (hasPefc && wantPEFC) certOK = true;
      if (hasNone && wantOHNE) certOK = true;
      if (!certOK) continue;

      // Landfilter
      if (!noCountryFilter) {
        if (!m.country_code || !selectedCountries.includes(m.country_code)) continue;
      }

      // Farbe nach berechnetem aktiven Preis
      const ap = activeCalcPriceForFirma(m, 250);
      const aktiveFarbe = colorForPrice(ap.price, ap.keinPreis);

      const isGruen  = aktiveFarbe === "green";
      const isOrange = aktiveFarbe === "orange";
      const isRot    = aktiveFarbe === "red";
      const isGrau   = aktiveFarbe === "#9e9e9e";

      let sichtbar = false;
      if(isGruen && gruen) sichtbar = true;
      if(isOrange && orange) sichtbar = true;
      if(isRot && rot) sichtbar = true;
      if(isGrau && grau) sichtbar = true;
      if(!sichtbar) continue;

      if (m.marker && m.marker.setStyle) m.marker.setStyle({ color: aktiveFarbe, fillColor: aktiveFarbe });
      if (m.marker && m.marker.getTooltip) m.marker.getTooltip().setContent( tooltipHtmlFirma(m) );

      map.addLayer(m.marker);
    }
  }

  // =======================
  // ROUTE
  // =======================
  function handleMarkerClick(label,coord){
    selectedPoints.push({label,coord});
    if(selectedPoints.length===2){
      const [a,b]=selectedPoints;
      showRoute(a,b);
      selectedPoints=[];
    }
  }

  async function showRoute(a,b){
    const url = `https://router.project-osrm.org/route/v1/driving/${a.coord.lon},${a.coord.lat};${b.coord.lon},${b.coord.lat}?overview=full&geometries=geojson`;
    const res = await fetch(url);
    const data = await res.json();
    if(!(data.routes && data.routes.length)){
      alert("Keine Route gefunden!");
      return;
    }

    const route = data.routes[0];
    const distKm = route.distance / 1000;
    const distTxt = distKm.toFixed(1);

    const durationMin = route.duration / 60;
    const hours = Math.floor(durationMin/60);
    const minutes = Math.round(durationMin%60);
    const durationStr = hours>0?`${hours}h ${minutes}min`:`${minutes}min`;

    const coords = route.geometry.coordinates.map(c=>[c[1],c[0]]);

    // Falls Start/Ziel Firma ist, nehmen wir deren Preise.
    // (Wenn beide Firmen, nehmen wir die erste gefundene - wie bisher)
    const firmaObjA = alleMarker.find(m => m.type==="firma" && m.firma === a.label);
    const firmaObjB = alleMarker.find(m => m.type==="firma" && m.firma === b.label);
    const firmeneintrag = firmaObjA || firmaObjB;

    if(routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(coords,{color:'blue',weight:5,opacity:0.8}).addTo(map);

    const mid = coords[Math.floor(coords.length/2)];

    let content = `
      <b>Route:</b> ${a.label} ‚Üî ${b.label}<br>
      <b>Entfernung:</b> ${distTxt} km<br>
      <b>Dauer:</b> ${durationStr}<br>
      <hr style="border:none;height:1px;background:#eee;margin:8px 0;">
    `;

    if(!firmeneintrag){
      content += `<b>Hinweis:</b> Keine Firma ausgew√§hlt ‚Äì keine Werkpreise verf√ºgbar.`;
      L.popup().setLatLng(mid).setContent(content).openOn(map);
      map.fitBounds(routeLine.getBounds(),{padding:[40,40]});
      return;
    }

    // ‚úÖ Berechnete Endpreise (nicht EK anzeigen)
    const ekH = firmeneintrag.prices?.hackschnitzel;
    const ekS = firmeneintrag.prices?.saegespaene;
    const ekM = firmeneintrag.prices?.siebmaterial;

    const calcH = (ekH !== undefined) ? calcHolzProdukt(ekH, distKm) : null;
    const calcS = (ekS !== undefined) ? calcHolzProdukt(ekS, distKm) : null;
    const calcM = (ekM !== undefined) ? calcSiebmaterial(ekM, distKm) : null;

    const lineH = `<b>Hackschnitzel:</b> ${calcH !== null ? calcH.toFixed(2) + " ‚Ç¨" : "‚Äì"}`;
    const lineS = `<b>S√§gesp√§ne:</b> ${calcS !== null ? calcS.toFixed(2) + " ‚Ç¨" : "‚Äì"}`;
    const lineM = `<b>Siebmaterial:</b> ${calcM !== null ? calcM.toFixed(2) + " ‚Ç¨" : "‚Äì"}`;

    content += `${lineH}<br>${lineS}<br>${lineM}`;

    L.popup().setLatLng(mid).setContent(content).openOn(map);
    map.fitBounds(routeLine.getBounds(),{padding:[40,40]});
  }

  map.on('click', (e) => {
    const t = e.originalEvent && e.originalEvent.target;
    if (t && t.closest) {
      if (t.closest('.leaflet-marker-icon') ||
          t.closest('.leaflet-popup') ||
          t.closest('.leaflet-interactive')) return;
    }
    if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
    selectedPoints = [];
    map.closePopup();
  });

  // =======================
  // Suche kann auch freie Orte geocodieren
  // =======================
  async function searchOrGeocode(query){
    const hit = alleMarker.find(m =>
      m.marker &&
      m.marker.getTooltip &&
      m.marker.getTooltip().getContent &&
      String(m.marker.getTooltip().getContent()).toLowerCase().includes(query)
    );
    if (hit) {
      const latlng = hit.marker.getLatLng();
      map.setView(latlng, 9);
      hit.marker.openTooltip();
      handleMarkerClick(hit.type==="firma" ? hit.firma : query.toUpperCase(), { lat: latlng.lat, lon: latlng.lng, country_code: hit.country_code || "" });
      return;
    }

    const c = await geocodeWithFallback([query]);
    if(!c){ alert("Kein Treffer gefunden."); return; }

    if (tempSearchMarker) map.removeLayer(tempSearchMarker);
    tempSearchMarker = L.marker([c.lat, c.lon], { icon: ortIcon })
      .bindTooltip(`<b>Ort:</b> ${query}`, {sticky:true})
      .addTo(map);

    map.setView([c.lat, c.lon], 10);
    tempSearchMarker.openTooltip();

    handleMarkerClick(`Ort: ${query}`, c);
  }

  // =======================
  // UI Events
  // =======================
  document.addEventListener("change", e => {
    if (e.target && e.target.matches('input[type="checkbox"]')) {
      if (e.target.classList.contains("countryChk")) {
        if (e.target.value === "all" && e.target.checked) {
          document.querySelectorAll(".countryChk").forEach(ch => { if (ch.value !== "all") ch.checked = false; });
        } else if (e.target.value !== "all" && e.target.checked) {
          const allChk = document.querySelector('.countryChk[value="all"]');
          if (allChk) allChk.checked = false;
        }
        updateCountryButtonLabel();
      }
      updateLayers();
    }
  });

  const countryBtn = document.getElementById("countryDropdownBtn");
  if (countryBtn) {
    countryBtn.addEventListener("click", () => {
      const menu = document.getElementById("countryDropdownMenu");
      if (!menu) return;
      menu.style.display = (menu.style.display === "block") ? "none" : "block";
    });
  }

  document.addEventListener("click", (e) => {
    const dd = document.getElementById("countryDropdown");
    const menu = document.getElementById("countryDropdownMenu");
    if (!dd || !menu) return;
    if (!dd.contains(e.target)) menu.style.display = "none";
  });

  const searchInput = document.getElementById("searchInput");
  if (searchInput) {
    searchInput.addEventListener("keydown", async (e) => {
      if(e.key === "Enter"){
        const query = e.target.value.toLowerCase().trim();
        if(!query) return;
        try{ await searchOrGeocode(query); }
        catch(err){ console.error(err); alert("Fehler beim Suchen/Geocoding."); }
      }
    });
  }

  // Start
  (async ()=>{
    try{
      await ladeDaten();
      await buildMap();
    }catch(err){
      console.error(err);
      alert("Fehler beim Laden. Bitte Konsole √∂ffnen (F12) f√ºr Details.");
    }
  })();
</script>

</body>
</html>
